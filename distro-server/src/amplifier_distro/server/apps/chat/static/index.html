<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Amplifier Chat</title>
  <style>
    /* —— Reset & Base ———————————————————————————————————— */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg-primary: #0d0d0d;
      --bg-secondary: #161616;
      --bg-tertiary: #1e1e1e;
      --bg-card: #1a1a1a;
      --border: rgba(255,255,255,0.08);
      --text-primary: #e8e8e8;
      --text-secondary: #999;
      --text-muted: #555;
      --accent-blue: #3b82f6;
      --accent-green: #22c55e;
      --accent-amber: #f59e0b;
      --accent-red: #ef4444;
      --status-connected: var(--accent-green);
      --status-connecting: var(--accent-amber);
      --status-disconnected: var(--accent-red);
    }

    body[data-theme="light"] {
      --bg-primary: #f4f6fb;
      --bg-secondary: #ffffff;
      --bg-tertiary: #eef2f7;
      --bg-card: #ffffff;
      --border: rgba(15, 23, 42, 0.12);
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
      --accent-blue: #2563eb;
      --accent-green: #16a34a;
      --accent-amber: #d97706;
      --accent-red: #dc2626;
    }

    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace;
      font-size: 14px;
      /* Use dvh (dynamic viewport height) for iOS to account for browser UI */
      height: 100vh; /* fallback for older browsers */
      height: 100dvh; /* modern browsers with dynamic viewport */
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* —— Header ——————————————————————————————————————————————— */
    #header {
      display: flex;
      align-items: center;
      gap: 12px;
      /* Add safe area padding for iOS notch/status bar */
      padding: max(8px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right)) 8px max(16px, env(safe-area-inset-left));
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      min-height: 44px;
      flex-shrink: 0;
    }

    .status-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--status-disconnected);
      flex-shrink: 0;
      transition: background 0.3s;
    }
    .status-dot.connected { background: var(--status-connected); }
    .status-dot.connecting { background: var(--status-connecting); }

    .app-name { font-weight: 600; color: var(--text-primary); }

    .header-spacer { flex: 1; }

    .btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
    }
    .btn:hover { background: var(--bg-card); color: var(--text-primary); }
    .btn.active { border-color: var(--accent-blue); color: var(--accent-blue); }

    .theme-toggle {
      display: inline-flex;
      align-items: center;
      gap: 2px;
      padding: 2px;
    }
    .theme-chip {
      width: 24px;
      height: 22px;
      border-radius: 5px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      transition: background 0.15s, color 0.15s;
    }
    .theme-chip.active {
      background: var(--accent-blue);
      color: #fff;
    }
    .theme-icon {
      width: 13px;
      height: 13px;
      color: currentColor;
      opacity: 1;
    }
    .theme-icon path,
    .theme-icon circle,
    .theme-icon line {
      vector-effect: non-scaling-stroke;
    }

    .icon {
      width: 14px;
      height: 14px;
      display: inline-block;
      vertical-align: middle;
      fill: none;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      flex-shrink: 0;
    }
    .icon.sm {
      width: 12px;
      height: 12px;
    }

    /* —— App Layout ——————————————————————————————————————————— */
    #app-body {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* —— Session Panel ————————————————————————————————————————— */
    #session-panel {
      width: 220px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: width 0.2s;
    }
    #session-panel.hidden { width: 0; overflow: hidden; }
    #session-panel.no-transition { transition: none; }

    .session-panel-header {
      padding: 10px;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: var(--bg-secondary);
    }
    .session-panel-header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      min-width: 0;
    }
    .session-panel-header-controls {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }
    .session-panel-title-wrap {
      min-width: 0;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--text-muted);
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .session-panel-header-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      align-items: center;
      gap: 6px;
    }
    .session-panel-header-actions.has-sync {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }
    .session-control-btn {
      min-width: 0;
      height: 26px;
      padding: 0 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
    }
    .session-control-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }
    .session-control-btn.active {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
      background: rgba(37, 99, 235, 0.08);
    }
    .session-control-btn:disabled {
      opacity: 0.65;
      cursor: default;
      border-color: var(--border);
      color: var(--text-muted);
    }
    .session-control-value {
      color: var(--text-muted);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }
    .session-new-btn {
      flex-shrink: 0;
      height: 26px;
      padding: 0 10px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
    }
    .session-new-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }
    .mobile-session-close {
      display: none;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      touch-action: manipulation;
    }
    .mobile-session-close:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }
    .mobile-sidebar-backdrop {
      display: none;
    }
    .session-filter-wrap {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }
    .session-filter-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 6px;
      outline: none;
    }
    .session-filter-input:focus {
      border-color: var(--accent-blue);
      color: var(--text-primary);
    }
    .session-filter-hint {
      margin-top: 5px;
      font-size: 10px;
      color: var(--text-muted);
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .session-list { flex: 1; overflow-y: auto; padding: 8px 0; }
    .session-list-loading {
      padding: 8px 12px;
      color: var(--text-secondary);
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .session-card {
      padding: 8px 12px;
      cursor: pointer;
      border-left: 2px solid transparent;
      transition: all 0.15s;
    }
    .session-card:hover { background: var(--bg-tertiary); }
    .session-card.active { border-left-color: var(--accent-blue); background: var(--bg-tertiary); }

    .session-card-name { font-size: 12px; font-weight: 500; color: var(--text-primary); }
    .session-card-cwd { font-size: 11px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .session-card-cwd-row { display: flex; align-items: center; gap: 6px; min-width: 0; }
    .session-card-line-text { min-width: 0; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .session-card-meta { font-size: 11px; color: var(--text-muted); display: flex; gap: 6px; align-items: center; margin-top: 2px; }
    .session-stale-badge {
      display: inline-flex;
      align-items: center;
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid rgba(245, 158, 11, 0.38);
      color: var(--accent-amber);
      font-size: 10px;
      font-weight: 600;
    }
    .session-stale-badge.new-session {
      border-color: rgba(99, 102, 241, 0.45);
      color: rgb(129, 140, 248);
      letter-spacing: 0.01em;
      text-transform: uppercase;
    }

    .session-actions {
      border-top: 1px solid var(--border);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex-shrink: 0;
    }

    .session-dir-group {
      border-top: 1px solid var(--border);
    }
    .session-dir-group:first-child {
      border-top: none;
    }
    .session-dir-header {
      width: 100%;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px 6px;
      cursor: pointer;
      text-align: left;
      font-size: 11px;
      font-weight: 600;
      min-width: 0;
    }
    .session-dir-header:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .session-dir-title {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .session-dir-count {
      color: var(--text-muted);
      font-size: 10px;
      flex-shrink: 0;
    }
    .session-dir-items {
      padding-left: 12px;
    }
    .session-tree-node {
      width: 100%;
    }
    .session-tree-row {
      display: flex;
      align-items: stretch;
      min-width: 0;
    }
    .session-tree-card-wrap {
      flex: 1;
      min-width: 0;
    }
    .session-tree-toggle {
      width: 20px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      flex-shrink: 0;
    }
    .session-tree-toggle:hover {
      color: var(--text-primary);
    }
    .session-tree-spacer {
      width: 20px;
      flex-shrink: 0;
      display: inline-block;
    }
    .session-tree-children {
      margin-left: 2px;
    }
    .new-session-cwd-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .new-session-cwd-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 4px;
      outline: none;
    }
    .new-session-cwd-input:focus {
      border-color: var(--accent-blue);
      color: var(--text-primary);
    }
    .session-meta-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 11px;
      color: var(--text-secondary);
    }
    .session-meta-row {
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
    }
    .session-meta-link {
      width: 100%;
      border: none;
      background: transparent;
      padding: 0;
      text-align: left;
      color: inherit;
      cursor: pointer;
      font: inherit;
      line-height: inherit;
    }
    .session-meta-link:hover .session-meta-value-link {
      text-decoration-color: currentColor;
    }
    .session-meta-link.pending {
      opacity: 0.65;
    }
    .session-meta-key {
      color: var(--text-muted);
      min-width: 34px;
      flex-shrink: 0;
    }
    .session-meta-value {
      display: block;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .session-meta-value-link {
      color: var(--accent-blue);
      text-decoration: underline;
      text-decoration-color: rgba(37, 99, 235, 0.45);
      text-underline-offset: 2px;
    }
    .active-cwd-display {
      font-size: 11px;
      color: var(--text-secondary);
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 8px;
    }
    .history-loading-banner {
      margin: 8px 12px 0;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .history-loading-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--accent-blue);
      opacity: 0.6;
      animation: pulse 1.2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 80%, 100% { opacity: 0.25; }
      40% { opacity: 1; }
    }

    /* —— Main Chat ——————————————————————————————————————————————— */
    #chat-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .pane-resizer {
      width: 6px;
      cursor: col-resize;
      background: transparent;
      border-left: 1px solid transparent;
      border-right: 1px solid transparent;
      flex-shrink: 0;
      transition: background 0.12s;
    }
    .pane-resizer:hover {
      background: rgba(59, 130, 246, 0.18);
    }
    .pane-resizer.active {
      background: rgba(59, 130, 246, 0.28);
    }

    /* Workspace mode layout */
    #chat-main.workspace-mode {
      flex-direction: row;
    }
    .main-pane { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .activity-panel {
      width: clamp(380px, 34vw, 560px);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg-secondary);
    }
    .activity-panel-header {
      padding: 8px 12px;
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .activity-scroll { flex: 1; overflow-y: auto; padding: 8px; }

    /* —— Message List ————————————————————————————————————————————— */
    #message-list {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .message-list-wrap {
      position: relative;
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .jump-nav {
      position: absolute;
      right: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 5;
      pointer-events: none;
    }
    .jump-btn {
      width: 28px;
      height: 28px;
      border: 1px solid var(--border);
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border-radius: 7px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      pointer-events: auto;
      transition: all 0.15s;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.25);
    }
    .jump-btn:hover {
      color: var(--text-primary);
      border-color: var(--accent-blue);
    }
    .jump-btn:disabled {
      opacity: 0.45;
      cursor: default;
    }
    .new-content-pill-wrap {
      position: absolute;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      z-index: 6;
      pointer-events: none;
    }
    .new-content-pill {
      pointer-events: auto;
      border: 1px solid rgba(30, 64, 175, 0.92);
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      color: #ffffff;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.01em;
      cursor: pointer;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.28);
      box-shadow:
        0 6px 20px rgba(37, 99, 235, 0.38),
        0 2px 10px rgba(0, 0, 0, 0.35);
      transition: background 0.15s, border-color 0.15s, transform 0.15s;
    }
    .new-content-pill:hover {
      background: linear-gradient(180deg, #60a5fa 0%, #2563eb 100%);
      border-color: rgba(29, 78, 216, 0.96);
      transform: translateY(-1px);
    }

    /* —— Text Blocks ——————————————————————————————————————————————— */
    .text-block {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .text-block[data-streaming="true"]::after {
      content: "▊";
      animation: cursor-pulse 1s step-end infinite;
      color: var(--accent-blue);
    }
    @keyframes cursor-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

    .text-block p { margin-bottom: 0.5em; }
    .text-block p:last-child { margin-bottom: 0; }
    .text-block ul,
    .text-block ol {
      margin: 0.45em 0 0.6em 0;
      padding-left: 1.4em;
    }
    .text-block li {
      margin: 0.2em 0;
    }
    .text-block code { background: var(--bg-tertiary); padding: 1px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em; }
    .text-block pre { background: var(--bg-tertiary); padding: 8px; border-radius: 4px; overflow-x: auto; }
    .text-block pre code { background: none; padding: 0; }

    /* User messages */
    .user-message {
      align-self: flex-end;
      background: var(--accent-blue);
      color: white;
      border: none;
      max-width: 75%;
    }

    /* System messages */
    .system-message {
      border-color: var(--accent-amber);
      color: var(--accent-amber);
      background: rgba(245,158,11,0.05);
      font-size: 12px;
      text-align: center;
    }
    .system-message.config-result {
      text-align: left;
      font-size: 13px;
      max-width: 100%;
    }
    .config-result pre {
      margin: 0;
      font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', monospace;
      font-size: 12px;
      line-height: 1.5;
      white-space: pre;
    }
    .config-result .config-heading {
      color: var(--text-primary);
      font-weight: 600;
      font-size: 13px;
    }
    .config-result .config-dim {
      opacity: 0.6;
    }

    /* —— Thinking Blocks ———————————————————————————————————————— */
    .thinking-block {
      border: 1px solid rgba(139,92,246,0.3);
      border-radius: 8px;
      background: rgba(139,92,246,0.05);
    }
    .thinking-header {
      padding: 6px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: rgba(139,92,246,0.8);
      user-select: none;
    }
    .thinking-header:hover { background: rgba(139,92,246,0.1); }
    .thinking-preview {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      color: var(--text-muted);
    }
    .thinking-content {
      padding: 8px 12px;
      font-size: 12px;
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      border-top: 1px solid rgba(139,92,246,0.2);
      max-height: none;
      overflow: visible;
    }
    .thinking-streaming { display: flex; gap: 3px; align-items: center; }
    .thinking-dot { width: 4px; height: 4px; border-radius: 50%; background: rgba(139,92,246,0.6); animation: thinking-pulse 1.2s ease-in-out infinite; }
    .thinking-dot:nth-child(2) { animation-delay: 0.2s; }
    .thinking-dot:nth-child(3) { animation-delay: 0.4s; }
    @keyframes thinking-pulse { 0%, 80%, 100% { opacity: 0.3; } 40% { opacity: 1; } }

    /* —— Tool Call Cards ——————————————————————————————————————————— */
    .tool-card {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-card);
      font-size: 12px;
    }
    .tool-header {
      padding: 6px 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      background: var(--bg-secondary);
    }
    .tool-header:hover { background: var(--bg-tertiary); }
    .tool-status { font-size: 13px; flex-shrink: 0; }
    .tool-name { font-weight: 500; color: var(--text-primary); }
    .token-usage-pill {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 2px 0 4px;
      font-size: 11px;
      color: var(--text-muted);
      opacity: 0.75;
      font-variant-numeric: tabular-nums;
    }
    .token-usage-pill .tok-sep { color: var(--border); }
    .tool-origin-badge {
      font-size: 10px;
      letter-spacing: 0.01em;
      text-transform: uppercase;
      color: var(--accent-amber);
      border: 1px solid rgba(245, 158, 11, 0.4);
      background: rgba(245, 158, 11, 0.1);
      border-radius: 999px;
      padding: 1px 6px;
      flex-shrink: 0;
      max-width: 180px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tool-arg-preview { color: var(--text-muted); overflow: hidden; white-space: nowrap; text-overflow: ellipsis; flex: 1; }
    .tool-body { padding: 8px 10px; border-top: 1px solid var(--border); }
    .tool-args-json { background: var(--bg-tertiary); padding: 6px 8px; border-radius: 4px; overflow-x: auto; white-space: pre; color: var(--text-secondary); font-family: monospace; font-size: 11px; }
    .tool-result-text {
      margin-top: 6px;
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      max-height: none;
      overflow: visible;
    }
    .tool-error-text { color: var(--accent-red); }

    .tool-marker { color: var(--text-muted); font-size: 11px; margin-left: 4px; }

    .status-running { animation: spin 1s linear infinite; display: inline-block; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* —— Sub-Session ————————————————————————————————————————————— */
    .sub-session {
      background: rgba(255,255,255,0.02);
      border-left: 2px solid var(--border);
      margin-top: 6px;
      padding: 6px 8px;
      font-size: 0.9em;
    }

    /* —— Approval Modal ———————————————————————————————————————————— */
    .modal-backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex; align-items: center; justify-content: center;
      z-index: 1000;
    }
    .modal-box {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 24px;
      max-width: 420px;
      width: 90%;
    }
    .modal-prompt { font-size: 14px; line-height: 1.5; margin-bottom: 16px; }
    .modal-progress {
      height: 3px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .modal-progress-bar {
      height: 100%;
      background: var(--accent-blue);
      animation: countdown linear forwards;
    }
    @keyframes countdown { from { width: 100%; } to { width: 0%; } }
    .modal-buttons { display: flex; gap: 8px; flex-wrap: wrap; }
    .modal-btn {
      flex: 1;
      min-width: 80px;
      padding: 8px 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .modal-btn.deny { background: var(--accent-red); color: white; }
    .modal-btn.allow { background: var(--accent-blue); color: white; }
    .modal-btn.always { background: var(--accent-green); color: white; }

    /* —— Input Area ————————————————————————————————————————————————— */
    #input-area {
      position: relative;
      border-top: 1px solid var(--border);
      /* Add safe area padding for iOS devices (bottom home indicator) */
      padding: 12px 16px calc(12px + env(safe-area-inset-bottom)) 16px;
      /* Ensure minimum touch target for iOS */
      min-height: calc(44px + env(safe-area-inset-bottom));
      background: var(--bg-secondary);
      flex-shrink: 0;
    }

    .image-previews {
      display: flex; flex-wrap: wrap; gap: 6px;
      margin-bottom: 8px;
    }
    .image-thumb {
      position: relative;
      width: 48px; height: 48px;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .image-thumb img { width: 100%; height: 100%; object-fit: cover; }
    .image-remove {
      position: absolute; top: 2px; right: 2px;
      width: 14px; height: 14px;
      background: rgba(0,0,0,0.7);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 9px;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }

    .input-row { display: flex; gap: 8px; align-items: flex-end; }

    #message-input {
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      resize: none;
      line-height: 1.4;
      min-height: 38px;
      max-height: 200px;
      overflow-y: auto;
      outline: none;
      font-family: inherit;
    }
    #message-input:focus { border-color: var(--accent-blue); }
    #message-input::placeholder { color: var(--text-muted); }

    .input-btn {
      height: 38px;
      padding: 0 14px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      flex-shrink: 0;
      white-space: nowrap;
    }
    .send-btn { background: var(--accent-blue); color: white; }
    .send-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .stop-btn { background: var(--accent-red); color: white; }
    .attach-btn { background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-secondary); }

    /* —— Slash command popup ——————————————————————————————————————— */
    .slash-popup {
      position: absolute;
      bottom: 100%;
      left: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 0;
      min-width: 200px;
      font-size: 12px;
    }
    .slash-cmd {
      padding: 4px 12px;
      cursor: pointer;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .slash-cmd:hover { background: var(--bg-tertiary); }
    .slash-cmd.active { background: var(--bg-tertiary); }
    .slash-cmd-name { color: var(--accent-blue); font-weight: 500; }
    .slash-cmd-desc { color: var(--text-muted); }

    /* —— Mobile —————————————————————————————————————————————————————— */
    .hamburger { display: none; }

    @media (max-width: 768px) {
      .hamburger {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px; height: 32px;
        background: none;
        border: 1px solid var(--border);
        border-radius: 4px;
        cursor: pointer;
        color: var(--text-secondary);
        font-size: 16px;
        touch-action: manipulation;
      }
      #session-panel {
        position: fixed;
        left: 0; top: 0; bottom: 0;
        z-index: 200;
        transform: translateX(-100%);
        transition: transform 0.2s;
        width: 260px !important;
      }
      #session-panel.mobile-open {
        transform: translateX(0);
        box-shadow: 4px 0 20px rgba(0,0,0,0.5);
      }
      .mobile-session-close {
        display: inline-flex;
      }
      .mobile-sidebar-backdrop {
        display: block;
        position: fixed;
        inset: 0;
        z-index: 150;
        border: 0;
        background: rgba(0, 0, 0, 0.45);
        touch-action: manipulation;
      }
      .workspace-toggle { display: none !important; }
      .activity-panel { display: none !important; }
      .pane-resizer { display: none !important; }
      #message-input { font-size: 16px; }
    }
  </style>
</head>
<body>
<script src="./vendor.js"></script>
<script>
  const { h, render } = window.preact;
  const { useState, useRef, useEffect, useCallback } = window.preactHooks;
  const { html } = window;
  const { marked } = window;

  // —— Constants ——————————————————————————————————————————————————————
  const SLASH_COMMANDS = [
    { name: '/help',    desc: 'Show available commands', clientSide: true },
    { name: '/clear',   desc: 'Clear conversation',      clientSide: true },
    { name: '/workspace', desc: 'Toggle workspace mode',       clientSide: true },
    { name: '/thinking', desc: 'Toggle thinking visibility', clientSide: true },
    { name: '/status',  desc: 'Session status',          clientSide: false },
    { name: '/tools',   desc: 'List tools',              clientSide: false },
    { name: '/agents',  desc: 'List agents',             clientSide: false },
    { name: '/bundle',  desc: 'Change bundle',           clientSide: false },
    { name: '/modes',   desc: 'List modes',              clientSide: false },
    { name: '/mode',    desc: 'Set mode',                clientSide: false },
    { name: '/config',  desc: 'Show session config',     clientSide: false },
  ];

  // —— Utilities ——————————————————————————————————————————————————————

  function formatCommandResult(command, result) {
    if (result.error) return { text: result.error };

    if (command === 'config' && result.type === 'config') {
      const h = s => '<span class="config-heading">' + s + '</span>';
      const d = s => '<span class="config-dim">' + s + '</span>';
      const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;');

      const lines = [];
      const sess = result.session || {};
      lines.push(h('Session'));
      lines.push('  orchestrator  ' + esc(sess.orchestrator || 'unknown'));
      lines.push('  context       ' + esc(sess.context || 'unknown'));

      if (result.providers && result.providers.length) {
        lines.push('');
        lines.push(h('Providers'));
        for (const p of result.providers) {
          let line = '  ' + esc(p.module);
          if (p.model) line += '  ' + d(esc(p.model));
          if (p.priority != null) line += '  ' + d('priority=' + p.priority);
          lines.push(line);
        }
      }

      if (result.tools && result.tools.length) {
        lines.push('');
        lines.push(h('Tools') + ' ' + d('(' + result.tools.length + ')'));
        for (const t of result.tools) lines.push('  ' + esc(t));
      }

      if (result.hooks && result.hooks.length) {
        lines.push('');
        lines.push(h('Hooks'));
        for (const hk of result.hooks) lines.push('  ' + esc(hk));
      }

      if (result.agents && result.agents.length) {
        lines.push('');
        lines.push(h('Agents') + ' ' + d('(' + result.agents.length + ')'));
        for (const a of result.agents) lines.push('  ' + esc(a));
      }

      return { html: '<pre>' + lines.join('\n') + '</pre>', cssClass: 'config-result' };
    }

    // Default: pretty-print JSON for other commands
    return { text: JSON.stringify(result, null, 2) };
  }

  function makeId() {
    return Math.random().toString(36).slice(2, 10);
  }

  function getArgPreview(toolName, args) {
    const field = {
      bash: 'command',
      read_file: 'file_path', write_file: 'file_path', edit_file: 'file_path',
      grep: 'pattern', glob: 'pattern',
      web_search: 'query', web_fetch: 'url',
      delegate: 'agent', task: 'agent',
    }[toolName];
    if (field && args[field]) return String(args[field]).slice(0, 60);
    const firstVal = Object.values(args || {})[0];
    return firstVal ? String(firstVal).slice(0, 60) : '';
  }

  function getToolStatusIcon(status) {
    return { pending: '⏱', running: '⟳', complete: '✓', error: '✗' }[status] || '⏱';
  }

  function truncate(s, n) {
    if (!s) return '';
    return s.length > n ? s.slice(0, n) + '…' : s;
  }

  function normalizeCwd(value) {
    const raw = typeof value === 'string' ? value : '~';
    const trimmed = raw.trim();
    return trimmed || '~';
  }

  function normalizeSessionParentId(value) {
    if (typeof value !== 'string') return null;
    const trimmed = value.trim();
    return trimmed || null;
  }

  function sessionUpdatedTs(session) {
    return Date.parse((session && session.lastUpdated) || '') || 0;
  }

  function compareSessionEntriesByRecent([keyA, a], [keyB, b]) {
    const tsA = sessionUpdatedTs(a);
    const tsB = sessionUpdatedTs(b);
    if (tsB !== tsA) return tsB - tsA;
    const cwdA = normalizeCwd(a && a.cwd).toLowerCase();
    const cwdB = normalizeCwd(b && b.cwd).toLowerCase();
    if (cwdA < cwdB) return -1;
    if (cwdA > cwdB) return 1;
    return keyA.localeCompare(keyB);
  }

  function buildSessionTree(entries) {
    const keyBySessionId = new Map();
    for (const [key, session] of entries) {
      const sid = session && typeof session.sessionId === 'string' ? session.sessionId : '';
      if (sid) keyBySessionId.set(sid, key);
    }

    const roots = [];
    const childrenByParentKey = new Map();
    for (const entry of entries) {
      const [key, session] = entry;
      const parentSessionId = normalizeSessionParentId(session && session.parentSessionId);
      const parentKey = parentSessionId ? keyBySessionId.get(parentSessionId) : null;
      if (!parentKey || parentKey === key) {
        roots.push(entry);
        continue;
      }
      const existing = childrenByParentKey.get(parentKey);
      if (existing) {
        existing.push(entry);
      } else {
        childrenByParentKey.set(parentKey, [entry]);
      }
    }

    roots.sort(compareSessionEntriesByRecent);
    for (const children of childrenByParentKey.values()) {
      children.sort(compareSessionEntriesByRecent);
    }

    return { roots, childrenByParentKey };
  }

  function sessionMatchesFilter(sessionKey, session, rawQuery) {
    const query = String(rawQuery || '').trim().toLowerCase();
    if (!query) return true;

    const s = session && typeof session === 'object' ? session : {};
    const sessionId = String(s.sessionId || '').toLowerCase();

    if (query.startsWith('sid:')) {
      const needle = query.slice(4).trim();
      if (!needle) return true;
      return sessionId.includes(needle);
    }

    const haystack = [
      sessionKey,
      s.sessionId,
      s.cwd,
      s.bundle,
      s.lastUserMessage,
      s.source,
      s.status,
      s.turnCount,
      s.messageCount,
      s.parentSessionId,
      s.spawnAgent,
    ]
      .filter(v => v !== null && v !== undefined && v !== '')
      .map(v => String(v).toLowerCase())
      .join(' ');
    return haystack.includes(query);
  }

  // Simple HTML sanitizer — strips dangerous tags and event handlers
  // TODO: Replace with DOMPurify in vendor.js for production use
  function sanitizeHtml(html) {
    const div = document.createElement('div');
    div.innerHTML = html;
    // Remove dangerous tags including style, base, meta, form
    const dangerous = div.querySelectorAll('script,iframe,object,embed,link,style,meta,base,form');
    dangerous.forEach(el => el.remove());
    // Remove dangerous attributes (event handlers, unsafe URLs)
    const UNSAFE_ATTRS = ['src', 'href', 'action', 'formaction', 'data', 'xlink:href'];
    const UNSAFE_PROTO = /^\s*(javascript|data|vbscript):/i;  // \s* handles whitespace bypass
    const allEls = div.querySelectorAll('*');
    allEls.forEach(el => {
      Array.from(el.attributes).forEach(attr => {
        if (attr.name.startsWith('on') ||
            (UNSAFE_ATTRS.includes(attr.name) && UNSAFE_PROTO.test(attr.value))) {
          el.removeAttribute(attr.name);
        }
      });
    });
    return div.innerHTML;
  }

  function transcriptToChronoItems(transcript) {
    const items = [];
    const toolCallIndexById = {};
    let order = 0;

    const toText = (value) => {
      if (typeof value === 'string') return value;
      if (Array.isArray(value)) {
        const parts = [];
        for (const block of value) {
          if (!block || typeof block !== 'object') continue;
          if (block.type === 'text' && typeof block.text === 'string') {
            parts.push(block.text);
          } else if (block.type === 'input_text' && typeof block.text === 'string') {
            parts.push(block.text);
          } else if (typeof block.content === 'string') {
            parts.push(block.content);
          }
        }
        return parts.join('\n');
      }
      return '';
    };

    for (const msg of (Array.isArray(transcript) ? transcript : [])) {
      if (!msg || typeof msg !== 'object') continue;
      const role = msg.role;
      const content = msg.content;

      if (role === 'user') {
        const text = toText(content);
        if (!text) continue;
        items.push({
          id: makeId(),
          type: 'text',
          role: 'user',
          content: text,
          streaming: false,
          order: order++,
        });
        continue;
      }

      if (role === 'assistant') {
        if (typeof content === 'string') {
          const parsedHtml = sanitizeHtml(marked.parse(content));
          items.push({
            id: makeId(),
            type: 'text',
            role: 'assistant',
            content,
            htmlContent: parsedHtml,
            streaming: false,
            order: order++,
          });
          continue;
        }

        const blocks = Array.isArray(content) ? content : [];
        for (const block of blocks) {
          if (!block || typeof block !== 'object') continue;
          if (block.type === 'text' && typeof block.text === 'string') {
            const parsedHtml = sanitizeHtml(marked.parse(block.text));
            items.push({
              id: makeId(),
              type: 'text',
              role: 'assistant',
              content: block.text,
              htmlContent: parsedHtml,
              streaming: false,
              order: order++,
            });
            continue;
          }
          if (block.type === 'thinking' && typeof block.thinking === 'string') {
            items.push({
              id: makeId(),
              type: 'thinking',
              content: block.thinking,
              streaming: false,
              order: order++,
            });
            continue;
          }
          if ((block.type === 'tool_use' || block.type === 'tool_call') && block.name) {
            const id = block.id || block.tool_call_id;
            const originSessionId = typeof block.session_id === 'string' ? block.session_id : null;
            const originParentId = typeof block.parent_id === 'string' ? block.parent_id : null;
            const subAgentName = typeof block.agent === 'string' ? block.agent : null;
            const item = {
              id: makeId(),
              type: 'tool_call',
              toolName: block.name,
              toolCallId: id || makeId(),
              arguments: block.input || block.arguments || {},
              toolStatus: 'complete',
              result: '',
              origin: originParentId ? 'sub-agent' : 'main',
              subAgentName,
              originSessionId,
              originParentId,
              streaming: false,
              order: order++,
            };
            const idx = items.length;
            items.push(item);
            if (id) toolCallIndexById[id] = idx;
          }
        }
        continue;
      }

      if (role === 'tool') {
        const blocks = Array.isArray(content) ? content : [content];
        for (const block of blocks) {
          if (!block || typeof block !== 'object') continue;
          const toolUseId = block.tool_use_id || block.tool_call_id;
          const idx = toolCallIndexById[toolUseId];
          if (idx === undefined) continue;
          const result = typeof block.content === 'string'
            ? block.content
            : JSON.stringify(block.content);
          items[idx] = {
            ...items[idx],
            result,
            toolStatus: block.is_error ? 'error' : 'complete',
          };
        }
      }
    }
    return items;
  }

  function countTranscriptMessages(transcript) {
    let count = 0;
    for (const msg of (Array.isArray(transcript) ? transcript : [])) {
      if (msg && typeof msg === 'object' && msg.role) count += 1;
    }
    return count;
  }

  function extractLastUserMessage(transcript) {
    const rows = Array.isArray(transcript) ? transcript : [];
    for (let i = rows.length - 1; i >= 0; i -= 1) {
      const msg = rows[i];
      if (!msg || typeof msg !== 'object' || msg.role !== 'user') continue;
      const content = msg.content;
      if (typeof content === 'string' && content.trim()) {
        return content.trim();
      }
      if (!Array.isArray(content)) continue;
      for (const block of content) {
        if (!block || typeof block !== 'object') continue;
        if (block.type === 'text' && typeof block.text === 'string' && block.text.trim()) {
          return block.text.trim();
        }
        if (block.type === 'input_text' && typeof block.text === 'string' && block.text.trim()) {
          return block.text.trim();
        }
      }
    }
    return null;
  }

  // —— Components ——————————————————————————————————————————————————————

  function StatusDot({ status }) {
    return html`<span class=${'status-dot ' + status}></span>`;
  }

  function Icon({ name, className = '' }) {
    const cls = ('icon ' + className).trim();
    switch (name) {
      case 'folder':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="M3 7h6l2 2h10v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"></path></svg>`;
      case 'bell':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="M15 17H5l1.5-2V10a5.5 5.5 0 0 1 11 0v5L19 17h-4"></path><path d="M10 17a2 2 0 0 0 4 0"></path></svg>`;
      case 'paperclip':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="M21 11.5 12.5 20a6 6 0 0 1-8.5-8.5l9.2-9.2a4.5 4.5 0 1 1 6.3 6.4L9.9 18.3a3 3 0 1 1-4.2-4.3l8.5-8.5"></path></svg>`;
      case 'thinking':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="M9.5 9a2.5 2.5 0 1 1 5 0c0 1.7-1.5 2.2-2.3 3.2-.4.5-.7 1-.7 1.8"></path><circle cx="12" cy="17.5" r="0.5"></circle><path d="M12 3.5a8.5 8.5 0 1 0 5.7 14.8L20.5 21l-.8-3a8.5 8.5 0 0 0-7.7-14.5z"></path></svg>`;
      case 'warning':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="M12 4 3.8 19h16.4L12 4z"></path><path d="M12 9v4"></path><path d="M12 16h0"></path></svg>`;
      case 'lock':
        return html`<svg class=${cls} viewBox="0 0 24 24"><rect x="5" y="11" width="14" height="10" rx="2"></rect><path d="M8 11V8a4 4 0 0 1 8 0v3"></path></svg>`;
      case 'chevron-up':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="m6 14 6-6 6 6"></path></svg>`;
      case 'chevron-down':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="m6 10 6 6 6-6"></path></svg>`;
      case 'chevron-right':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="m10 6 6 6-6 6"></path></svg>`;
      case 'refresh':
        return html`<svg class=${cls} viewBox="0 0 24 24"><path d="M21 12a9 9 0 1 1-2.6-6.3"></path><path d="M21 3v6h-6"></path></svg>`;
      default:
        return null;
    }
  }

  function ThinkingBlock({ item }) {
    const [expanded, setExpanded] = useState(false);
    const preview = typeof item.content === 'string'
      ? item.content.replace(/\s+/g, ' ').trim()
      : '';
    return html`
      <div class="thinking-block">
        <div class="thinking-header" onClick=${() => setExpanded(e => !e)}>
          <${Icon} name="thinking" />
          ${item.streaming
            ? html`<span class="thinking-streaming">
                <span class="thinking-dot"></span>
                <span class="thinking-dot"></span>
                <span class="thinking-dot"></span>
              </span>`
            : html`<span class="thinking-preview">${preview || 'Thinking…'}</span>`
          }
          <span>${expanded ? '▼' : '▶'}</span>
        </div>
        ${expanded && html`<div class="thinking-content" id=${item.id}>${item.content}</div>`}
      </div>
    `;
  }

  function ToolCallCard({ item, isActivity }) {
    const [expanded, setExpanded] = useState(false);
    const statusIcon = getToolStatusIcon(item.toolStatus);
    const isRunning = item.toolStatus === 'running';
    const argPreview = getArgPreview(item.toolName, item.arguments || {});
    const subAgentName = item.subAgentName ? truncate(item.subAgentName, 24) : null;
    const isSubAgentTool = item.origin === 'sub-agent' || isActivity;
    const originLabel = isSubAgentTool
      ? (subAgentName ? ('sub-agent · ' + subAgentName) : 'sub-agent')
      : null;
    const originTitle = item.originSessionId
      ? ('Executed in delegated session ' + item.originSessionId)
      : 'Executed in a delegated sub-agent session';

    // Keep card sizing/layout unchanged; only auto-open once result is available.
    useEffect(() => {
      if (item.toolStatus === 'complete' || item.toolStatus === 'error') {
        setExpanded(true);
      }
    }, [item.toolStatus]);

    return html`
      <div class="tool-card">
        <div class="tool-header" onClick=${() => setExpanded(e => !e)}>
          <span class=${'tool-status' + (isRunning ? ' status-running' : '')}>${statusIcon}</span>
          <span class="tool-name">${item.toolName || 'tool'}</span>
          ${originLabel && html`<span class="tool-origin-badge" title=${originTitle}>${originLabel}</span>`}
          <span class="tool-arg-preview">${argPreview}</span>
        </div>
        ${expanded && html`
          <div class="tool-body">
            <pre class="tool-args-json">${JSON.stringify(item.arguments || {}, null, 2)}</pre>
            ${item.result && html`
              <div class=${'tool-result-text' + (item.resultError ? ' tool-error-text' : '')}>
                ${item.resultError || item.result || ''}
              </div>
            `}
            ${item.subSessionId && html`<${SubSessionView} sessionId=${item.subSessionId} items=${item.subItems || []} />`}
          </div>
        `}
      </div>
    `;
  }

  function SubSessionView({ sessionId, items }) {
    return html`
      <div class="sub-session">
        ${items.map(item => html`<${ChronoItem} item=${item} isActivity=${true} />`)}
      </div>
    `;
  }

  function TokenUsagePill({ tokens }) {
    if (!tokens) return null;
    const fmt = n => n >= 1000 ? (n / 1000).toFixed(1) + 'K' : String(n || 0);
    const parts = [
      `↑ ${fmt(tokens.input_tokens)} in`,
      `↓ ${fmt(tokens.output_tokens)} out`,
    ];
    if (tokens.cache_read_tokens > 0) {
      parts.push(`${fmt(tokens.cache_read_tokens)} cached`);
    }
    return html`
      <div class="token-usage-pill">
        ${parts.map((p, i) => [
          html`<span>${p}</span>`,
          i < parts.length - 1 ? html`<span class="tok-sep">·</span>` : null,
        ])}
      </div>
    `;
  }

  function ChronoItem({ item, isActivity }) {
    if (item.type === 'text') {
      const cls = 'text-block'
        + (item.role === 'user' ? ' user-message' : '')
        + (item.role === 'system' ? ' system-message' : '')
        + (item.cssClass ? ' ' + item.cssClass : '');
      if (item.htmlContent) {
        return html`<div class=${cls} id=${item.id}
          dangerouslySetInnerHTML=${{ __html: item.htmlContent }}></div>`;
      }
      return html`<div class=${cls} id=${item.id}
        data-streaming=${item.streaming ? 'true' : 'false'}>${item.content}</div>`;
    }
    if (item.type === 'thinking') {
      return html`<${ThinkingBlock} item=${item} />`;
    }
    if (item.type === 'tool_call') {
      return html`<${ToolCallCard} item=${item} isActivity=${isActivity} />`;
    }
    if (item.type === 'token_usage') {
      return html`<${TokenUsagePill} tokens=${item.tokens} />`;
    }
    return null;
  }

  function MessageList({
    items,
    filterFn,
    sessionKey,
    showJumpControls = false,
    bottomNoticeSignal = 0,
    bottomNoticeLabel = 'New messages',
  }) {
    const filtered = filterFn ? items.filter(filterFn) : items;
    const sorted = [...filtered].sort((a, b) => a.order - b.order);
    const listRef = useRef(null);
    const bottomRef = useRef(null);
    const [scrollState, setScrollState] = useState({
      canTop: false,
      canBottom: false,
      hasOverflow: false,
    });
    const nearBottomRef = useRef(true);
    const initialAnchorDoneRef = useRef(false);
    const [showBottomNotice, setShowBottomNotice] = useState(false);
    const lastNoticeSignalRef = useRef(bottomNoticeSignal);

    const updateScrollState = useCallback(() => {
      const el = listRef.current;
      if (!el) return;
      const maxTop = Math.max(0, el.scrollHeight - el.clientHeight);
      const canTop = el.scrollTop > 12;
      const canBottom = maxTop - el.scrollTop > 12;
      const hasOverflow = maxTop > 8;
      nearBottomRef.current = !canBottom;
      setScrollState(prev => (
        prev.canTop === canTop
        && prev.canBottom === canBottom
        && prev.hasOverflow === hasOverflow
      ) ? prev : { canTop, canBottom, hasOverflow });
    }, []);

    useEffect(() => {
      initialAnchorDoneRef.current = false;
      nearBottomRef.current = true;
      lastNoticeSignalRef.current = bottomNoticeSignal;
      setShowBottomNotice(false);
      setScrollState({ canTop: false, canBottom: false, hasOverflow: false });
    }, [sessionKey]);

    useEffect(() => {
      if (bottomNoticeSignal === lastNoticeSignalRef.current) return;
      lastNoticeSignalRef.current = bottomNoticeSignal;
      if (nearBottomRef.current) return;
      setShowBottomNotice(true);
      updateScrollState();
    }, [bottomNoticeSignal, updateScrollState]);

    // Anchor to newest on first load per session.
    useEffect(() => {
      if (!sorted.length) return;
      const el = listRef.current;
      if (!el) return;

      const anchor = () => {
        el.scrollTop = el.scrollHeight;
        updateScrollState();
      };

      if (!initialAnchorDoneRef.current) {
        requestAnimationFrame(() => requestAnimationFrame(anchor));
        initialAnchorDoneRef.current = true;
        return;
      }

      if (nearBottomRef.current) {
        requestAnimationFrame(anchor);
      } else {
        updateScrollState();
      }
    }, [sorted.length, updateScrollState]);

    const jumpTop = useCallback(() => {
      const el = listRef.current;
      if (!el) return;
      el.scrollTo({ top: 0, behavior: 'smooth' });
    }, []);

    const jumpBottom = useCallback(() => {
      setShowBottomNotice(false);
      bottomRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }, []);

    useEffect(() => {
      if (!scrollState.canBottom) {
        setShowBottomNotice(false);
      }
    }, [scrollState.canBottom]);

    return html`
      <div class="message-list-wrap">
        <div id="message-list" ref=${listRef} onScroll=${updateScrollState}>
          ${sorted.map(item => html`<${ChronoItem} key=${item.id} item=${item} />`)}
          <div ref=${bottomRef}></div>
        </div>
        ${showJumpControls && scrollState.hasOverflow && html`
          <div class="jump-nav">
            <button class="jump-btn" title="Jump to top" onClick=${jumpTop} disabled=${!scrollState.canTop}>
              <${Icon} name="chevron-up" className="sm" />
            </button>
            <button class="jump-btn" title="Jump to bottom" onClick=${jumpBottom} disabled=${!scrollState.canBottom}>
              <${Icon} name="chevron-down" className="sm" />
            </button>
          </div>
        `}
        ${showBottomNotice && scrollState.canBottom && html`
          <div class="new-content-pill-wrap">
            <button class="new-content-pill" title="Jump to latest messages" onClick=${jumpBottom}>
              ${bottomNoticeLabel} ↓
            </button>
          </div>
        `}
      </div>
    `;
  }

  function ApprovalModal({ approval, onRespond }) {
    if (!approval) return null;
    // Validate: must be a number between 5 and 600 seconds
    const rawTimeout = Number(approval.timeout);
    const timeout = isFinite(rawTimeout) ? Math.max(5, Math.min(600, rawTimeout)) : 300;
    return html`
      <div class="modal-backdrop">
        <div class="modal-box">
          <div class="modal-prompt">${approval.prompt}</div>
          <div class="modal-progress">
            <div class="modal-progress-bar" style=${'animation-duration:' + timeout + 's'}></div>
          </div>
          <div class="modal-buttons">
            ${(approval.options || ['deny', 'allow']).map(opt => {
              const cls = 'modal-btn ' + (
                opt.includes('deny') ? 'deny' :
                opt.includes('always') ? 'always' : 'allow'
              );
              return html`<button class=${cls} onClick=${() => onRespond(opt)}>${opt}</button>`;
            })}
          </div>
        </div>
      </div>
    `;
  }

  function SessionCard({ session, isActive, onClick }) {
    const statusIcon =
      session.status === 'running' ? '⟳ ' :
      session.status === 'connecting' ? '◌ ' :
      session.status === 'loading_history' ? '◌ ' :
      session.status === 'history' ? '◴ ' :
      session.status === 'error' ? '✗ ' :
      '';
    const metaText = session.source === 'history'
      ? `${session.messageCount || session.turnCount || 0} msgs`
      : `turn ${session.turnCount || 0}`;
    const preview = session.lastUserMessage || null;
    const sessionName =
      session.name
      || session.bundle
      || (
        session.source !== 'history' && (session.turnCount || 0) === 0
          ? 'new session'
          : 'session'
      );
    return html`
      <div class=${'session-card' + (isActive ? ' active' : '')} onClick=${onClick}>
        <div class="session-card-name">
          ${statusIcon}
          ${sessionName}
          ${session.pendingApproval ? html`<${Icon} name="bell" className="sm" />` : ''}
        </div>
        <div class="session-card-cwd session-card-cwd-row" title=${session.cwd || '~'}>
          <${Icon} name="folder" className="sm" />
          <span class="session-card-line-text">${session.cwd || '~'}</span>
        </div>
        <div class="session-card-meta">
          <span>${metaText}</span>
          ${session.hasExternalUpdate
            ? html`<span class="session-stale-badge ${session.isNewSession ? 'new-session' : ''}">${session.isNewSession ? 'New' : 'Updated'}</span>`
            : null}
        </div>
        ${preview ? html`<div class="session-card-cwd" title=${session.lastUserMessage || ''}>${preview}</div>` : null}
      </div>
    `;
  }

  function InputArea({ onSend, onStop, executing, viewMode, setViewMode, activeKey }) {
    const textareaRef = useRef(null);
    const fileInputRef = useRef(null);
    const [pendingImages, setPendingImages] = useState([]);
    const [slashOpen, setSlashOpen] = useState(false);
    const [slashFilter, setSlashFilter] = useState('');
    const [slashActiveIndex, setSlashActiveIndex] = useState(0);

    useEffect(() => {
      const ta = textareaRef.current;
      if (!ta || ta.disabled) return;
      const rafId = window.requestAnimationFrame(() => {
        try {
          ta.focus();
        } catch {}
      });
      return () => window.cancelAnimationFrame(rafId);
    }, [activeKey]);

    const autoResize = useCallback(() => {
      const ta = textareaRef.current;
      if (!ta) return;
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 200) + 'px';
    }, []);

    const addImages = useCallback((files) => {
      Array.from(files).forEach(file => {
        if (!file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = e => {
          setPendingImages(prev => [...prev, e.target.result]);
        };
        reader.readAsDataURL(file);
      });
    }, []);

    const handlePaste = useCallback((e) => {
      const items = e.clipboardData?.items || [];
      const hasImage = Array.from(items).some(i => i.type.startsWith('image/'));
      if (!hasImage) return;
      e.preventDefault();
      const files = Array.from(items)
        .filter(i => i.type.startsWith('image/'))
        .map(i => i.getAsFile());
      addImages(files);
    }, [addImages]);

    const doSend = useCallback(() => {
      if (executing) return;  // Guard against double-send
      const ta = textareaRef.current;
      if (!ta) return;
      const content = ta.value.trim();
      if (!content && pendingImages.length === 0) return;

      // Strip data URL prefix from images
      const images = pendingImages.map(d => d.split(',')[1]);
      onSend(content, images);
      ta.value = '';
      ta.style.height = 'auto';
      setPendingImages([]);
      setSlashOpen(false);
    }, [onSend, pendingImages, executing]);

    const applySlashCommand = useCallback((cmdName) => {
      const ta = textareaRef.current;
      if (!ta) return;
      ta.value = cmdName + ' ';
      ta.focus();
      autoResize();
      setSlashOpen(false);
      setSlashActiveIndex(0);
    }, [autoResize]);

    const filteredCmds = SLASH_COMMANDS.filter(c =>
      c.name.slice(1).startsWith(slashFilter)
    );
    const slashMenuOpen = slashOpen && filteredCmds.length > 0;
    const activeSlashIndex = Math.max(0, Math.min(slashActiveIndex, filteredCmds.length - 1));
    const slashPopupId = 'slash-command-popup';
    const activeSlashOptionId = slashMenuOpen
      ? ('slash-command-option-' + activeSlashIndex)
      : null;

    useEffect(() => {
      if (!slashMenuOpen) return;
      setSlashActiveIndex(i => Math.max(0, Math.min(i, filteredCmds.length - 1)));
    }, [slashMenuOpen, filteredCmds.length]);

    const handleKeyDown = useCallback((e) => {
      if (slashMenuOpen) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          setSlashActiveIndex(i => (i + 1) % filteredCmds.length);
          return;
        }
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          setSlashActiveIndex(i => (i - 1 + filteredCmds.length) % filteredCmds.length);
          return;
        }
        if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Tab') {
          e.preventDefault();
          const cmd = filteredCmds[activeSlashIndex];
          if (cmd) applySlashCommand(cmd.name);
          return;
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          setSlashOpen(false);
          setSlashActiveIndex(0);
          return;
        }
      }
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        doSend();
      }
      if (e.key === 'Escape') {
        setSlashOpen(false);
        setSlashActiveIndex(0);
      }
    }, [doSend, slashMenuOpen, filteredCmds, activeSlashIndex, applySlashCommand]);

    const handleInput = useCallback((e) => {
      autoResize();
      const val = e.target.value;
      if (val.startsWith('/')) {
        setSlashOpen(true);
        setSlashFilter(val.slice(1).toLowerCase());
        setSlashActiveIndex(0);
      } else {
        setSlashOpen(false);
        setSlashActiveIndex(0);
      }
    }, [autoResize]);

    return html`
      <div id="input-area">
        ${pendingImages.length > 0 && html`
          <div class="image-previews">
            ${pendingImages.map((src, i) => html`
              <div class="image-thumb">
                <img src=${src} alt="attachment" />
                <button class="image-remove" onClick=${() => setPendingImages(p => p.filter((_, j) => j !== i))}>×</button>
              </div>
            `)}
          </div>
        `}
        ${slashMenuOpen && html`
          <div
            class="slash-popup"
            id=${slashPopupId}
            role="listbox"
            aria-label="Slash commands"
          >
            ${filteredCmds.map((cmd, idx) => html`
              <div
                id=${'slash-command-option-' + idx}
                class=${'slash-cmd' + (idx === activeSlashIndex ? ' active' : '')}
                role="option"
                aria-selected=${idx === activeSlashIndex ? 'true' : 'false'}
                onMouseEnter=${() => setSlashActiveIndex(idx)}
                onMouseDown=${e => e.preventDefault()}
                onClick=${() => applySlashCommand(cmd.name)}
              >
                <span class="slash-cmd-name">${cmd.name}</span>
                <span class="slash-cmd-desc">${cmd.desc}</span>
              </div>
            `)}
          </div>
        `}
        <div class="input-row">
          <textarea
            id="message-input"
            ref=${textareaRef}
            placeholder=${executing ? "Processing…" : "Message… (/ for commands)"}
            rows="1"
            disabled=${executing}
            style=${{ opacity: executing ? 0.6 : 1 }}
            aria-label="Message input"
            aria-autocomplete="list"
            aria-expanded=${slashMenuOpen ? 'true' : 'false'}
            aria-controls=${slashMenuOpen ? slashPopupId : null}
            aria-activedescendant=${slashMenuOpen ? activeSlashOptionId : null}
            onInput=${handleInput}
            onKeyDown=${handleKeyDown}
            onPaste=${handlePaste}
            onDragOver=${e => e.preventDefault()}
            onDrop=${e => { e.preventDefault(); addImages(e.dataTransfer.files); }}
          ></textarea>
          <button class="input-btn attach-btn" title="Attach image" onClick=${() => fileInputRef.current?.click()}>
            <${Icon} name="paperclip" />
          </button>
          <input ref=${fileInputRef} type="file" accept="image/*" multiple style="display:none" onChange=${e => addImages(e.target.files)} />
          ${executing
            ? html`<button class="input-btn stop-btn" onClick=${onStop}>■ Stop</button>`
            : html`<button class="input-btn send-btn" onClick=${doSend}>Send</button>`
          }
        </div>
      </div>
    `;
  }

  // —— ChatApp root ——————————————————————————————————————————————————————
  function ChatApp() {
    // Connection
    const [wsStatus, setWsStatus] = useState('disconnected');
    const wsRef = useRef(null);

    // Sessions: Map<wsKey, SessionState>
    const [sessions, setSessions] = useState(new Map());
    const [activeKey, setActiveKey] = useState(null);
    const sessionCounterRef = useRef(0);

    // Current session state
    const [chronoItems, setChronoItems] = useState([]);
    const [executing, setExecuting] = useState(false);
    const [pendingApproval, setPendingApproval] = useState(null);
    const [sessionId, setSessionId] = useState(null);
    const [cwd, setCwd] = useState('~');
    const [defaultCwd, setDefaultCwd] = useState('~');
    const [turnCount, setTurnCount] = useState(0);
    const [diskUpdateNoticeSignal, setDiskUpdateNoticeSignal] = useState(0);

    // UI state
    const [viewMode, setViewMode] = useState('chat');
    const [showSessions, setShowSessions] = useState(true);
    const [mobileSidebarOpen, setMobileSidebarOpen] = useState(false);
    const [syncingHistory, setSyncingHistory] = useState(false);
    const [historyListLoading, setHistoryListLoading] = useState(true);
    const [pendingHistorySyncCount, setPendingHistorySyncCount] = useState(0);
    const [sessionSortMode, setSessionSortMode] = useState('recent');
    const [sessionFilterQuery, setSessionFilterQuery] = useState('');
    const [showSessionFilter, setShowSessionFilter] = useState(false);
    const [collapsedDirGroups, setCollapsedDirGroups] = useState({});
    const [collapsedSpawnGroups, setCollapsedSpawnGroups] = useState({});
    const [sessionPanelWidth, setSessionPanelWidth] = useState(300);
    const [activityPanelWidth, setActivityPanelWidth] = useState(460);
    const [draggingPane, setDraggingPane] = useState(null);
    const [theme, setTheme] = useState(() => {
      try {
        const saved = localStorage.getItem('chat-theme');
        if (saved === 'light' || saved === 'dark') return saved;
        if (
          typeof window !== 'undefined'
          && window.matchMedia
          && window.matchMedia('(prefers-color-scheme: light)').matches
        ) {
          return 'light';
        }
      } catch {}
      return 'dark';
    });

    // Refs (no re-renders)
    const orderCounterRef = useRef(0);
    const blockMapRef = useRef({});
    const cycleRef = useRef(0);
    const localIndexRef = useRef(0);
    const toolMapRef = useRef({});
    const childToToolRef = useRef({});
    const childAgentRef = useRef({});
    const sessionParentByIdRef = useRef({});
    const activeKeyRef = useRef(null);
    const sessionsRef = useRef(new Map());
    const chronoItemsRef = useRef([]);
    const turnCountRef = useRef(0);
    const defaultCwdRef = useRef('~');
    const draftCwdSyncKeyRef = useRef(null);
    const pendingEventsRef = useRef(new Map());
    const historyResumeTokenRef = useRef(0);
    const dragStateRef = useRef(null);
    // Accumulates token usage across LLM calls within a single turn
    const turnTokensRef = useRef(null);
    const revisionPollInFlightRef = useRef(false);
    const historySyncInFlightRef = useRef(false);
    const historyDiscoverInFlightRef = useRef(false);
    const transcriptFetchAbortRef = useRef(null);
    const diskRefreshInFlightRef = useRef(new Set());
    const autoDiskRefreshAtRef = useRef({});

    useEffect(() => {
      activeKeyRef.current = activeKey;
    }, [activeKey]);

    useEffect(() => {
      chronoItemsRef.current = chronoItems;
    }, [chronoItems]);

    useEffect(() => {
      sessionsRef.current = sessions;
    }, [sessions]);

    useEffect(() => {
      turnCountRef.current = turnCount;
    }, [turnCount]);

    useEffect(() => {
      defaultCwdRef.current = defaultCwd;
    }, [defaultCwd]);

    // Load workspace_root from distro settings as initial default CWD
    useEffect(() => {
      fetch('/apps/settings/distro-settings')
        .then(r => r.ok ? r.json() : null)
        .then(data => {
          const root = data?.settings?.workspace_root;
          if (root && typeof root === 'string') {
            defaultCwdRef.current = root;
            setDefaultCwd(root);
            setCwd(root);
          }
        })
        .catch(() => {});
    }, []);

    useEffect(() => {
      return () => {
        if (transcriptFetchAbortRef.current) {
          try { transcriptFetchAbortRef.current.abort(); } catch {}
          transcriptFetchAbortRef.current = null;
        }
      };
    }, []);

    useEffect(() => {
      document.body.setAttribute('data-theme', theme);
      try {
        localStorage.setItem('chat-theme', theme);
      } catch {}
    }, [theme]);

    useEffect(() => {
      const onMouseMove = (e) => {
        const drag = dragStateRef.current;
        if (!drag) return;
        const dx = e.clientX - drag.startX;
        if (drag.pane === 'sessions') {
          const min = 180;
          const max = Math.max(260, Math.min(560, window.innerWidth * 0.6));
          const next = Math.max(min, Math.min(max, drag.startWidth + dx));
          setSessionPanelWidth(next);
          return;
        }
        if (drag.pane === 'activity') {
          const min = 280;
          const max = Math.max(360, Math.min(900, window.innerWidth - 320));
          const next = Math.max(min, Math.min(max, drag.startWidth - dx));
          setActivityPanelWidth(next);
        }
      };

      const onMouseUp = () => {
        if (!dragStateRef.current) return;
        dragStateRef.current = null;
        setDraggingPane(null);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      };

      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      return () => {
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      };
    }, []);

    useEffect(() => {
      if (!activeKey) return;
      const active = sessions.get(activeKey);
      if (!active) return;
      const isDraft =
        active.source !== 'history'
        && (active.turnCount || 0) === 0;
      if (!isDraft) {
        if (draftCwdSyncKeyRef.current === activeKey) {
          draftCwdSyncKeyRef.current = null;
        }
        return;
      }
      if (draftCwdSyncKeyRef.current === activeKey) return;
      const nextCwd = active.cwd || cwd || '~';
      draftCwdSyncKeyRef.current = activeKey;
      defaultCwdRef.current = nextCwd;
      setDefaultCwd(nextCwd);
    }, [activeKey, sessions, cwd]);

    useEffect(() => {
      if (!mobileSidebarOpen) return;
      const onKeyDown = (e) => {
        if (e.key === 'Escape') {
          setMobileSidebarOpen(false);
        }
      };
      window.addEventListener('keydown', onKeyDown);
      return () => {
        window.removeEventListener('keydown', onKeyDown);
      };
    }, [mobileSidebarOpen]);

    // —— Index mapping ————————————————————————————————————————————
    function getLocalIndex(serverIndex) {
      const key = `${cycleRef.current}-${serverIndex}`;
      if (!(key in blockMapRef.current)) {
        blockMapRef.current[key] = localIndexRef.current++;
      }
      return blockMapRef.current[key];
    }

    function getRequestedCwd() {
      return (defaultCwdRef.current || '').trim() || '~';
    }

    function nextOrder(items) {
      if (!Array.isArray(items) || items.length === 0) return 0;
      let maxOrder = -1;
      for (const item of items) {
        const order = Number(item?.order);
        if (Number.isFinite(order) && order > maxOrder) {
          maxOrder = order;
        }
      }
      return maxOrder + 1;
    }

    const applySessionForkLineage = useCallback((msg) => {
      const childId = normalizeSessionParentId(msg && msg.child_id);
      const parentId = normalizeSessionParentId(msg && msg.parent_id);
      const childAgent = typeof msg?.agent === 'string' && msg.agent ? msg.agent : null;

      if (childId && childAgent) {
        childAgentRef.current[childId] = childAgent;
      }
      if (childId && parentId) {
        sessionParentByIdRef.current[childId] = parentId;
      }
      if (!childId) return;

      setSessions(prev => {
        let changed = false;
        const next = new Map(prev);
        for (const [key, session] of next.entries()) {
          if (!session || session.sessionId !== childId) continue;
          const nextParent = parentId || session.parentSessionId || null;
          const nextAgent = childAgent || session.spawnAgent || null;
          if (nextParent === session.parentSessionId && nextAgent === session.spawnAgent) {
            continue;
          }
          next.set(key, {
            ...session,
            parentSessionId: nextParent,
            spawnAgent: nextAgent,
          });
          changed = true;
        }
        return changed ? next : prev;
      });
    }, []);

    // —— WebSocket event handler ————————————————————————————————————
    const handleWsMessage = useCallback((msg, sourceKey = null) => {
      const ownerKey = sourceKey || activeKeyRef.current;
      const isActiveStream = ownerKey === activeKeyRef.current;
      if (!ownerKey) return;
      if (!isActiveStream) {
        // Keep session list metadata live even when this session is in
        // background, and queue renderable events for later replay.
        if (msg.type === 'session_created') {
          const nowIso = new Date().toISOString();
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            const parentSessionId = normalizeSessionParentId(
              sessionParentByIdRef.current[msg.session_id] || s.parentSessionId
            );
            const spawnAgent = childAgentRef.current[msg.session_id] || s.spawnAgent || null;
            next.set(ownerKey, {
              ...s,
              sessionId: msg.session_id,
              cwd: msg.cwd || '~',
              bundle: msg.bundle,
              source: 'live',
              status: 'idle',
              lastUpdated: s.lastUpdated || nowIso,
              hasExternalUpdate: false,
              isNewSession: false,
              parentSessionId,
              spawnAgent,
            });
            return next;
          });
          return;
        }

        if (msg.type === 'prompt_complete') {
          const nowIso = new Date().toISOString();
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            const nextTurn = (s.turnCount || 0) + 1;
            next.set(ownerKey, {
              ...s,
              turnCount: nextTurn,
              savedTurnCount: nextTurn,
              status: 'idle',
              pendingApproval: false,
              lastUpdated: nowIso,
            });
            return next;
          });
          return;
        }

        if (msg.type === 'execution_cancelled') {
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            next.set(ownerKey, { ...s, status: 'idle' });
            return next;
          });
          return;
        }

        if (msg.type === 'approval_request') {
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            next.set(ownerKey, { ...s, pendingApproval: true });
            return next;
          });
          return;
        }

        if (msg.type === 'execution_error') {
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            next.set(ownerKey, {
              ...s,
              status: s.source === 'history' ? 'history' : 'error',
            });
            return next;
          });
        }

        if (msg.type === 'session_fork') {
          applySessionForkLineage(msg);
        }

        if (msg.type !== 'auth_ok' && msg.type !== 'pong' && msg.type !== 'prompt_complete') {
          const queued = pendingEventsRef.current.get(ownerKey) || [];
          queued.push(msg);
          pendingEventsRef.current.set(ownerKey, queued);
        }
        return;
      }

      switch (msg.type) {
        case 'auth_ok':
          break;

        case 'session_created': {
          const nowIso = new Date().toISOString();
          if (isActiveStream) {
            setSessionId(msg.session_id);
            setCwd(msg.cwd || '~');
          }
          if (!ownerKey) break;
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            const parentSessionId = normalizeSessionParentId(
              sessionParentByIdRef.current[msg.session_id] || s.parentSessionId
            );
            const spawnAgent = childAgentRef.current[msg.session_id] || s.spawnAgent || null;
            next.set(ownerKey, {
              ...s,
              sessionId: msg.session_id,
              cwd: msg.cwd || '~',
              bundle: msg.bundle,
              source: 'live',
              status: 'idle',
              turnCount: s.turnCount || 0,
              lastUpdated: s.lastUpdated || nowIso,
              hasExternalUpdate: false,
              isNewSession: false,
              parentSessionId,
              spawnAgent,
            });
            return next;
          });
          break;
        }

        case 'content_start':
          if (msg.block_type === 'text') {
            const itemId = makeId();
            const localIdx = getLocalIndex(msg.index);
            blockMapRef.current['id-' + localIdx] = itemId;
            setChronoItems(prev => [...prev, {
              id: itemId, type: 'text', content: '', streaming: true,
              order: orderCounterRef.current++, role: 'assistant',
            }]);
          } else if (msg.block_type === 'thinking') {
            const itemId = makeId();
            const localIdx = getLocalIndex(msg.index);
            blockMapRef.current['thinking-id-' + localIdx] = itemId;
            setChronoItems(prev => [...prev, {
              id: itemId, type: 'thinking', content: '', streaming: true,
              order: orderCounterRef.current++,
            }]);
          }
          break;

        case 'content_delta': {
          const delta = typeof msg.delta === 'string' ? msg.delta : '';
          if (!delta) break;
          const localIdx = getLocalIndex(msg.index);
          const textItemId = blockMapRef.current['id-' + localIdx];
          const thinkingItemId = blockMapRef.current['thinking-id-' + localIdx];

          if (textItemId) {
            const el = document.getElementById(textItemId);
            if (el) {
              el.textContent += delta;
            } else {
              setChronoItems(prev => prev.map(item =>
                item.id === textItemId
                  ? { ...item, content: item.content + delta }
                  : item
              ));
            }
          }

          if (thinkingItemId) {
            setChronoItems(prev => prev.map(item =>
              item.id === thinkingItemId
                ? { ...item, content: item.content + delta }
                : item
            ));
          }
          break;
        }

        case 'content_end': {
          const localIdx = getLocalIndex(msg.index);
          const payloadText = typeof msg.text === 'string' ? msg.text : '';
          const textItemId = blockMapRef.current['id-' + localIdx];
          const thinkingItemId = blockMapRef.current['thinking-id-' + localIdx];
          const el = textItemId ? document.getElementById(textItemId) : null;
          const domText = el?.textContent || '';

          setChronoItems(prev => prev.map(item => {
            if (item.id === textItemId) {
              const finalText = payloadText || domText || item.content || '';
              const parsedHtml = sanitizeHtml(marked.parse(finalText));
              return {
                ...item,
                streaming: false,
                content: finalText,
                htmlContent: parsedHtml,
              };
            }
            if (item.id === thinkingItemId) {
              const finalThinking = payloadText || item.content || '';
              return {
                ...item,
                streaming: false,
                content: finalThinking,
              };
            }
            return item;
          }));
          break;
        }

        case 'thinking_delta': {
          // Use state update so content accumulates even when collapsed
          setChronoItems(prev => prev.map(item =>
            item.type === 'thinking' && item.streaming
              ? { ...item, content: item.content + msg.delta }
              : item
          ));
          break;
        }

        case 'thinking_final': {
          setChronoItems(prev => prev.map(item =>
            item.type === 'thinking' && item.streaming
              ? { ...item, content: msg.content, streaming: false }
              : item
          ));
          break;
        }

        case 'token_usage': {
          // Accumulate across multiple LLM calls in the same turn (tool loops)
          const prev = turnTokensRef.current || {};
          turnTokensRef.current = {
            input_tokens:       (prev.input_tokens  || 0) + (msg.input_tokens  || 0),
            output_tokens:      (prev.output_tokens || 0) + (msg.output_tokens || 0),
            total_tokens:       (prev.total_tokens  || 0) + (msg.total_tokens  || 0),
            cache_read_tokens:  (prev.cache_read_tokens  || 0) + (msg.cache_read_tokens  || 0),
            cache_write_tokens: (prev.cache_write_tokens || 0) + (msg.cache_write_tokens || 0),
            model:    msg.model    || prev.model,
            provider: msg.provider || prev.provider,
          };
          break;
        }

        case 'tool_call': {
          const itemId = makeId();
          const originSessionId = typeof msg.session_id === 'string' ? msg.session_id : null;
          const originParentId = typeof msg.parent_id === 'string' ? msg.parent_id : null;
          const subAgentName = originSessionId ? childAgentRef.current[originSessionId] : null;
          const isSubAgentTool = !!originParentId || !!(originSessionId && childToToolRef.current[originSessionId]);
          toolMapRef.current[msg.tool_call_id] = itemId;
          setChronoItems(prev => [...prev, {
            id: itemId, type: 'tool_call',
            toolName: msg.tool_name, toolCallId: msg.tool_call_id,
            arguments: msg.arguments || {},
            toolStatus: 'running',
            origin: isSubAgentTool ? 'sub-agent' : 'main',
            subAgentName: typeof subAgentName === 'string' && subAgentName ? subAgentName : null,
            originSessionId,
            originParentId,
            order: orderCounterRef.current++,
          }]);
          setExecuting(true);
          break;
        }

        case 'tool_result': {
          const itemId = toolMapRef.current[msg.tool_call_id];
          cycleRef.current++;
          setChronoItems(prev => prev.map(item =>
            item.id === itemId
              ? { ...item, toolStatus: msg.success ? 'complete' : 'error', result: msg.output, resultError: msg.error }
              : item
          ));
          break;
        }

        case 'session_fork': {
          const parentToolId = toolMapRef.current[msg.parent_tool_call_id];
          const childId = typeof msg.child_id === 'string' ? msg.child_id : null;
          applySessionForkLineage(msg);
          if (parentToolId) {
            if (childId) childToToolRef.current[childId] = parentToolId;
          }
          break;
        }

        case 'display_message': {
          setChronoItems(prev => [...prev, {
            id: makeId(), type: 'text', role: 'system',
            content: `[${msg.level}] ${msg.message}`,
            streaming: false, order: orderCounterRef.current++,
          }]);
          break;
        }

        case 'approval_request':
          if (isActiveStream) {
            setPendingApproval(msg);
          }
          setSessions(prev => {
            const next = new Map(prev);
            if (ownerKey && next.has(ownerKey)) {
              const s = next.get(ownerKey);
              next.set(ownerKey, { ...s, pendingApproval: true });
            }
            return next;
          });
          break;

        case 'prompt_complete':
          {
            const nowIso = new Date().toISOString();
            let nextTurn = null;
            setSessions(prev => {
              const next = new Map(prev);
              const s = next.get(ownerKey) || {};
              nextTurn = (s.turnCount || 0) + 1;
              next.set(ownerKey, {
                ...s,
                turnCount: nextTurn,
                savedTurnCount: nextTurn,
                status: 'idle',
                pendingApproval: false,
                lastUpdated: nowIso,
              });
              return next;
            });
            setExecuting(false);
            setTurnCount(nextTurn ?? (turnCountRef.current + 1));
          }
          // Flush accumulated token usage as a chrono item
          if (turnTokensRef.current && (turnTokensRef.current.total_tokens || 0) > 0) {
            const snapTokens = turnTokensRef.current;
            setChronoItems(prev => [...prev, {
              id: makeId(),
              type: 'token_usage',
              order: orderCounterRef.current++,
              tokens: snapTokens,
            }]);
            turnTokensRef.current = null;
          }
          blockMapRef.current = {};
          cycleRef.current = 0;
          localIndexRef.current = 0;
          break;

        case 'execution_cancelled':
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            next.set(ownerKey, { ...s, status: 'idle' });
            return next;
          });
          setExecuting(false);
          break;

        case 'execution_error':
          setSessions(prev => {
            const next = new Map(prev);
            const s = next.get(ownerKey) || {};
            next.set(ownerKey, {
              ...s,
              status: s.source === 'history' ? 'history' : 'error',
            });
            return next;
          });
          setExecuting(false);
          setChronoItems(prev => [...prev, {
            id: makeId(), type: 'text', role: 'system',
            content: 'Warning: ' + (msg.error || 'Unknown error'),
            streaming: false, order: orderCounterRef.current++,
          }]);
          break;

        case 'command_result': {
          const fmt = formatCommandResult(msg.command, msg.result);
          const item = {
            id: makeId(), type: 'text', role: 'system',
            streaming: false, order: orderCounterRef.current++,
          };
          if (fmt.html) {
            item.htmlContent = fmt.html;
            item.cssClass = fmt.cssClass || '';
          } else {
            item.content = fmt.text;
          }
          setChronoItems(prev => [...prev, item]);
          break;
        }

        case 'cancel_acknowledged':
          // Server received the cancel request; awaiting full stop
          // Show brief indicator that cancel is in progress
          setChronoItems(prev => [...prev, {
            id: makeId(), type: 'text', role: 'system',
            content: 'Cancellation requested…',
            streaming: false, order: orderCounterRef.current++,
          }]);
          break;

        case 'pong':
          break;

        default:
          break;
      }
    }, [applySessionForkLineage]);

    // —— WebSocket connection ————————————————————————————————————————
    const connect = useCallback((sessionKey) => {
      const rs = wsRef.current?.readyState;
      if (rs === WebSocket.OPEN || rs === WebSocket.CONNECTING) return;
      setWsStatus('connecting');

      const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
      const ws = new WebSocket(`${proto}//${location.host}/apps/chat/ws`);
      wsRef.current = ws;

      ws.onopen = () => {
        if (activeKeyRef.current === sessionKey) {
          setWsStatus('connected');
        }
        const requestedCwd = getRequestedCwd();
        setSessions(prev => {
          if (!sessionKey) return prev;
          const next = new Map(prev);
          const s = next.get(sessionKey) || {};
          next.set(sessionKey, { ...s, ws, cwd: s.cwd || requestedCwd });
          return next;
        });
        ws.send(JSON.stringify({ type: 'create_session', cwd: requestedCwd, bundle: null }));
      };

      ws.onmessage = (e) => {
        try {
          handleWsMessage(JSON.parse(e.data), sessionKey);
        } catch (err) {
          console.error('WS parse error', err);
        }
      };

      ws.onclose = (e) => {
        if (activeKeyRef.current === sessionKey) {
          setWsStatus('disconnected');
          if (e.code !== 4001 && e.code !== 4003) {
            setTimeout(() => connect(activeKeyRef.current), 3000);
          }
        }
      };

      ws.onerror = () => {
        if (activeKeyRef.current === sessionKey) {
          setWsStatus('disconnected');
        }
      };
    }, [handleWsMessage]);

    const discoverNewHistorySessions = useCallback(() => {
      if (historyDiscoverInFlightRef.current || historySyncInFlightRef.current) return;
      historyDiscoverInFlightRef.current = true;

      fetch('/apps/chat/api/sessions/history?limit=300')
        .then(r => {
          if (!r.ok) throw new Error('history discover failed: ' + r.status);
          return r.json();
        })
        .then(data => {
          const rows = Array.isArray(data?.sessions) ? data.sessions : [];
          if (!rows.length) {
            setPendingHistorySyncCount(0);
            return;
          }

          const knownSessionIds = new Set();
          for (const session of sessionsRef.current.values()) {
            if (session && session.sessionId) knownSessionIds.add(session.sessionId);
          }

          let pending = 0;
          for (const s of rows.slice(0, 300)) {
            if (!s || !s.session_id) continue;
            const messageCount = Number(s.message_count) || 0;
            if (messageCount <= 0 && !s.last_user_message) continue;
            if (!knownSessionIds.has(s.session_id)) pending += 1;
          }
          setPendingHistorySyncCount(pending);
        })
        .catch(err => {
          console.warn('[chat] failed to discover new session history', err);
        })
        .finally(() => {
          historyDiscoverInFlightRef.current = false;
        });
    }, []);

    const syncSessionHistory = useCallback((options = {}) => {
      const silent = !!options.silent;
      if (historySyncInFlightRef.current) return;
      historySyncInFlightRef.current = true;
      if (!silent) setSyncingHistory(true);

      fetch('/apps/chat/api/sessions/history?limit=300')
        .then(r => {
          if (!r.ok) throw new Error('history fetch failed: ' + r.status);
          return r.json();
        })
        .then(data => {
          const rows = Array.isArray(data?.sessions) ? data.sessions : [];
          if (!rows.length) {
            setPendingHistorySyncCount(0);
            return;
          }

          setSessions(prev => {
            const next = new Map(prev);
            const sessionKeyById = new Map();
            for (const [key, session] of next.entries()) {
              if (session && session.sessionId) {
                sessionKeyById.set(session.sessionId, key);
              }
            }

            let changed = false;
            for (const s of rows.slice(0, 300)) {
              if (!s || !s.session_id) continue;
              const messageCount = Number(s.message_count) || 0;
              if (messageCount <= 0 && !s.last_user_message) continue;

              const sessionId = s.session_id;
              const revision = typeof s.revision === 'string' ? s.revision : null;
              const parentSessionId = normalizeSessionParentId(
                s.parent_session_id || sessionParentByIdRef.current[sessionId]
              );
              const spawnAgent = (
                (typeof s.spawn_agent === 'string' && s.spawn_agent)
                || childAgentRef.current[sessionId]
                || null
              );
              if (parentSessionId) {
                sessionParentByIdRef.current[sessionId] = parentSessionId;
              }
              if (spawnAgent) {
                childAgentRef.current[sessionId] = spawnAgent;
              }
              const existingKey = sessionKeyById.get(sessionId);

              if (!existingKey) {
                const historyKey = 'history-' + sessionId;
                if (next.has(historyKey)) continue;
                // New session never seen by this client.
                // Only badge on explicit user-initiated sync (!silent) — not on
                // initial page load or background refresh, which would flag every
                // historical session as "New" after a server restart.
                const hasContent = messageCount > 0;
                const badgeNew = !silent && hasContent;
                next.set(historyKey, {
                  source: 'history',
                  status: 'history',
                  sessionId,
                  cwd: s.cwd || '~',
                  turnCount: messageCount,
                  savedTurnCount: messageCount,
                  messageCount,
                  lastUserMessage: s.last_user_message || null,
                  lastUpdated: s.last_updated || null,
                  name: s.name || null,
                  description: s.description || null,
                  knownRevision: badgeNew ? null : revision,
                  remoteRevision: revision,
                  hasExternalUpdate: badgeNew,
                  isNewSession: badgeNew,
                  parentSessionId,
                  spawnAgent,
                  name: s.name || null,
                  description: s.description || null,
                });
                sessionKeyById.set(sessionId, historyKey);
                changed = true;
                continue;
              }

              const cur = next.get(existingKey) || {};
              const remoteRevision = revision ?? cur.remoteRevision ?? null;
              const knownRevision = cur.knownRevision == null ? remoteRevision : cur.knownRevision;
              const hasExternalUpdate = !!cur.hasExternalUpdate
                || (
                  knownRevision != null
                  && remoteRevision != null
                  && knownRevision !== remoteRevision
                );

              const treatAsHistory = cur.source === 'history' || !cur.ws;
              const nextSource = treatAsHistory ? 'history' : cur.source;
              const nextStatus = treatAsHistory
                ? ((cur.status && cur.status !== 'history') ? cur.status : 'history')
                : cur.status;
              const nextTurnCount = (
                treatAsHistory && (cur.status === 'history' || cur.source === 'history')
              )
                ? (messageCount || cur.turnCount || 0)
                : cur.turnCount;
              const nextSavedTurnCount = (
                treatAsHistory && (cur.status === 'history' || cur.source === 'history')
              )
                ? (messageCount || cur.savedTurnCount || cur.turnCount || 0)
                : cur.savedTurnCount;
              const nextMessageCount = messageCount || cur.messageCount || cur.turnCount || 0;
              const nextCwd = s.cwd || cur.cwd || '~';
              const nextLastUserMessage = s.last_user_message || cur.lastUserMessage || null;
              const nextLastUpdated = s.last_updated || cur.lastUpdated || null;
              const nextParentSessionId = parentSessionId || cur.parentSessionId || null;
              const nextSpawnAgent = spawnAgent || cur.spawnAgent || null;
              const nextName = s.name || cur.name || null;
              const nextDescription = s.description || cur.description || null;

              const rowChanged =
                nextCwd !== cur.cwd
                || nextMessageCount !== cur.messageCount
                || nextLastUserMessage !== cur.lastUserMessage
                || nextLastUpdated !== cur.lastUpdated
                || remoteRevision !== cur.remoteRevision
                || knownRevision !== cur.knownRevision
                || hasExternalUpdate !== !!cur.hasExternalUpdate
                || nextSource !== cur.source
                || nextStatus !== cur.status
                || nextTurnCount !== cur.turnCount
                || nextSavedTurnCount !== cur.savedTurnCount
                || nextParentSessionId !== cur.parentSessionId
                || nextSpawnAgent !== cur.spawnAgent
                || nextName !== cur.name
                || nextDescription !== cur.description;

              if (!rowChanged) continue;

              next.set(existingKey, {
                ...cur,
                source: nextSource,
                status: nextStatus,
                cwd: nextCwd,
                turnCount: nextTurnCount,
                savedTurnCount: nextSavedTurnCount,
                messageCount: nextMessageCount,
                lastUserMessage: nextLastUserMessage,
                lastUpdated: nextLastUpdated,
                knownRevision,
                remoteRevision,
                hasExternalUpdate,
                parentSessionId: nextParentSessionId,
                spawnAgent: nextSpawnAgent,
                name: nextName,
                description: nextDescription,
              });
              changed = true;
            }

            return changed ? next : prev;
          });
          setPendingHistorySyncCount(0);
        })
        .catch(err => {
          console.warn('[chat] failed to load session history', err);
        })
        .finally(() => {
          historySyncInFlightRef.current = false;
          setHistoryListLoading(false);
          if (!silent) setSyncingHistory(false);
        });
    }, []);

    useEffect(() => {
      const key = 'session-' + (++sessionCounterRef.current);
      const initialCwd = getRequestedCwd();
      const nowIso = new Date().toISOString();
      activeKeyRef.current = key;
      setActiveKey(key);
      setSessions(new Map([[key, {
        status: 'idle',
        turnCount: 0,
        cwd: initialCwd,
        lastUpdated: nowIso,
      }]]));
      connect(key);
      syncSessionHistory({ silent: true });
    }, [connect, syncSessionHistory]);

    useEffect(() => {
      const onFocus = () => discoverNewHistorySessions();
      const onVisibility = () => {
        if (document.visibilityState === 'visible') {
          const rs = wsRef.current?.readyState;
          if (rs == null || rs === WebSocket.CLOSED || rs === WebSocket.CLOSING) {
            connect(activeKeyRef.current);
          }
          discoverNewHistorySessions();
        }
      };
      const intervalId = window.setInterval(() => {
        discoverNewHistorySessions();
      }, 30000);

      window.addEventListener('focus', onFocus);
      document.addEventListener('visibilitychange', onVisibility);
      return () => {
        window.clearInterval(intervalId);
        window.removeEventListener('focus', onFocus);
        document.removeEventListener('visibilitychange', onVisibility);
      };
    }, [connect, discoverNewHistorySessions]);

    useEffect(() => {
      if (sessionSortMode !== 'directory') return;
      const groupKeys = new Set();
      const allEntries = Array.from(sessions.entries());
      const tree = buildSessionTree(allEntries);
      for (const [, session] of tree.roots) {
        groupKeys.add(normalizeCwd(session && session.cwd));
      }
      setCollapsedDirGroups(prev => {
        const next = { ...prev };
        let changed = false;
        for (const key of groupKeys) {
          if (!(key in next)) {
            next[key] = true;
            changed = true;
          }
        }
        for (const key of Object.keys(next)) {
          if (!groupKeys.has(key)) {
            delete next[key];
            changed = true;
          }
        }
        return changed ? next : prev;
      });
    }, [sessionSortMode, sessions]);

    useEffect(() => {
      const allEntries = Array.from(sessions.entries());
      const tree = buildSessionTree(allEntries);
      const parentIds = new Set();
      for (const [key, session] of tree.roots) {
        const children = tree.childrenByParentKey.get(key) || [];
        if (!children.length) continue;
        const sid = session && session.sessionId ? session.sessionId : key;
        parentIds.add(sid);
      }
      for (const children of tree.childrenByParentKey.values()) {
        for (const [key, session] of children) {
          const grandchildren = tree.childrenByParentKey.get(key) || [];
          if (!grandchildren.length) continue;
          const sid = session && session.sessionId ? session.sessionId : key;
          parentIds.add(sid);
        }
      }
      setCollapsedSpawnGroups(prev => {
        const next = { ...prev };
        let changed = false;
        for (const sid of parentIds) {
          if (!(sid in next)) {
            next[sid] = true;
            changed = true;
          }
        }
        for (const sid of Object.keys(next)) {
          if (!parentIds.has(sid)) {
            delete next[sid];
            changed = true;
          }
        }
        return changed ? next : prev;
      });
    }, [sessions]);

    const toggleDirGroup = useCallback((groupKey) => {
      setCollapsedDirGroups(prev => {
        const current = Object.prototype.hasOwnProperty.call(prev, groupKey)
          ? !!prev[groupKey]
          : true;
        return {
          ...prev,
          [groupKey]: !current,
        };
      });
    }, []);

    const toggleSpawnGroup = useCallback((parentId) => {
      setCollapsedSpawnGroups(prev => {
        const current = Object.prototype.hasOwnProperty.call(prev, parentId)
          ? !!prev[parentId]
          : true;
        return {
          ...prev,
          [parentId]: !current,
        };
      });
    }, []);

    // —— Send ————————————————————————————————————————————————————————
    const sendMessage = useCallback((content, images) => {
      const key = activeKeyRef.current;
      const activeSession = key ? sessionsRef.current.get(key) : null;
      const activeWs = activeSession?.ws || null;

      if (!activeWs || activeWs.readyState !== WebSocket.OPEN) {
        // Visible feedback instead of silent return
        setChronoItems(prev => [...prev, {
          id: makeId(), type: 'text', role: 'system',
          content: 'Warning: Not connected. Message not sent. Reconnecting…',
          streaming: false, order: orderCounterRef.current++,
        }]);
        return;
      }

      // Client-side slash commands
      if (content.startsWith('/')) {
        const parts = content.trim().split(/\s+/);
        const cmd = parts[0];
        const args = parts.slice(1);

        if (cmd === '/cwd') {
          setChronoItems(prev => [...prev, {
            id: makeId(), type: 'text', role: 'system',
            content: 'Use "New Session CWD" (left panel) and start a new session.',
            streaming: false, order: orderCounterRef.current++,
          }]);
          return;
        }

        switch (cmd) {
          case '/help': {
            const helpText = SLASH_COMMANDS.map(c => `${c.name} — ${c.desc}`).join('\n');
            setChronoItems(prev => [...prev, {
              id: makeId(), type: 'text', role: 'system',
              content: helpText, streaming: false, order: orderCounterRef.current++,
            }]);
            return;
          }
          case '/clear':
            setChronoItems([]);
            return;
          case '/workspace':
            setViewMode(m => m === 'workspace' ? 'chat' : 'workspace');
            return;
          case '/thinking':
            // Toggle visibility — implemented in Phase 6
            return;
        }
        // Server-side commands
        activeWs.send(JSON.stringify({ type: 'command', name: cmd.slice(1), args }));
        return;
      }

      // Normal message
      setChronoItems(prev => [...prev, {
        id: makeId(), type: 'text', role: 'user',
        content, streaming: false, order: orderCounterRef.current++,
      }]);
      setExecuting(true);
      const nowIso = new Date().toISOString();
      setSessions(prev => {
        const next = new Map(prev);
        const key = activeKeyRef.current;
        if (key && next.has(key)) {
          const s = next.get(key);
          next.set(key, {
            ...s,
            status: 'running',
            lastUserMessage: content || s.lastUserMessage || null,
            lastUpdated: nowIso,
          });
        }
        return next;
      });

      const payload = { type: 'prompt', content };
      if (images && images.length > 0) payload.images = images;
      activeWs.send(JSON.stringify(payload));
    }, []);

    const stopExecution = useCallback(() => {
      const key = activeKeyRef.current;
      const activeSession = key ? sessionsRef.current.get(key) : null;
      const activeWs = activeSession?.ws || null;
      if (activeWs?.readyState === WebSocket.OPEN) {
        activeWs.send(JSON.stringify({ type: 'cancel', level: 'graceful' }));
      }
    }, []);

    const respondToApproval = useCallback((choice) => {
      const key = activeKeyRef.current;
      const activeSession = key ? sessionsRef.current.get(key) : null;
      const activeWs = activeSession?.ws || null;
      if (pendingApproval && activeWs?.readyState === WebSocket.OPEN) {
        activeWs.send(JSON.stringify({
          type: 'approval_response',
          id: pendingApproval.id,
          choice,
        }));
      }
      setPendingApproval(null);
      setSessions(prev => {
        const next = new Map(prev);
        const key = activeKeyRef.current;
        if (key && next.has(key)) {
          const s = next.get(key);
          next.set(key, { ...s, pendingApproval: false });
        }
        return next;
      });
    }, [pendingApproval]);

    const newSession = useCallback(() => {
      const requestedCwd = getRequestedCwd();
      const nowIso = new Date().toISOString();
      if (transcriptFetchAbortRef.current) {
        try { transcriptFetchAbortRef.current.abort(); } catch {}
        transcriptFetchAbortRef.current = null;
      }
      const prevKey = activeKeyRef.current;
      if (prevKey) {
        setSessions(prev => {
          const next = new Map(prev);
          const cur = next.get(prevKey) || {};
          next.set(prevKey, {
            ...cur,
            savedItems: chronoItemsRef.current,
            savedTurnCount: turnCountRef.current,
          });
          return next;
        });
      }

      const key = 'session-' + (++sessionCounterRef.current);
      activeKeyRef.current = key;
      setActiveKey(key);
      setChronoItems([]);
      orderCounterRef.current = 0;
      setTurnCount(0);
      setExecuting(false);
      setPendingApproval(null);
      setSessionId(null);
      setCwd(requestedCwd);
      setWsStatus('connecting');
      setSessions(prev => {
        const next = new Map(prev);
        next.set(key, {
          status: 'connecting',
          turnCount: 0,
          cwd: requestedCwd,
          lastUpdated: nowIso,
        });
        return next;
      });
      blockMapRef.current = {};
      cycleRef.current = 0;
      localIndexRef.current = 0;
      toolMapRef.current = {};

      const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
      const ws = new WebSocket(`${proto}//${location.host}/apps/chat/ws`);
      wsRef.current = ws;
      setSessions(prev => {
        const next = new Map(prev);
        const cur = next.get(key) || {};
        next.set(key, { ...cur, ws });
        return next;
      });

      ws.onopen = () => {
        if (activeKeyRef.current === key) {
          wsRef.current = ws;
          setWsStatus('connected');
        }
        ws.send(JSON.stringify({ type: 'create_session', cwd: requestedCwd, bundle: null }));
        setSessions(prev => {
          const next = new Map(prev);
          const cur = next.get(key) || {};
          next.set(key, { ...cur, ws, status: 'idle' });
          return next;
        });
      };

      ws.onmessage = (e) => {
        try { handleWsMessage(JSON.parse(e.data), key); } catch {}
      };
      ws.onclose = () => {
        if (activeKeyRef.current === key) {
          setWsStatus('disconnected');
        }
        pendingEventsRef.current.delete(key);
        setSessions(prev => {
          const next = new Map(prev);
          next.delete(key);
          return next;
        });
      };
    }, [handleWsMessage]);

    const resumeHistorySession = useCallback((key) => {
      const target = sessions.get(key);
      if (!target || !target.sessionId) return;

      if (transcriptFetchAbortRef.current) {
        try { transcriptFetchAbortRef.current.abort(); } catch {}
      }
      const transcriptAbort = new AbortController();
      transcriptFetchAbortRef.current = transcriptAbort;

      const resumeToken = ++historyResumeTokenRef.current;

      const currentKey = activeKeyRef.current;
      if (currentKey && currentKey !== key) {
        setSessions(prev => {
          const next = new Map(prev);
          const cur = next.get(currentKey) || {};
          next.set(currentKey, {
            ...cur,
            savedItems: chronoItemsRef.current,
            savedTurnCount: turnCountRef.current,
          });
          return next;
        });
      }

      activeKeyRef.current = key;
      setActiveKey(key);
      setMobileSidebarOpen(false);
      setExecuting(false);
      setPendingApproval(null);
      setSessionId(target.sessionId);
      setCwd(target.cwd || '~');
      const cachedItems = target.savedItems || [];
      setChronoItems(cachedItems);
      orderCounterRef.current = nextOrder(cachedItems);
      setTurnCount(target.savedTurnCount || target.turnCount || 0);
      setWsStatus('connecting');
      wsRef.current = null;
      setSessions(prev => {
        const next = new Map(prev);
        const cur = next.get(key) || {};
        next.set(key, { ...cur, status: 'loading_history', source: 'history' });
        return next;
      });
      blockMapRef.current = {};
      cycleRef.current = 0;
      localIndexRef.current = 0;
      toolMapRef.current = {};

      if (target.ws && (
        target.ws.readyState === WebSocket.OPEN ||
        target.ws.readyState === WebSocket.CONNECTING
      )) {
        try { target.ws.close(1000, 'Resuming session'); } catch {}
      }

      fetch('/apps/chat/api/sessions/' + encodeURIComponent(target.sessionId) + '/transcript', {
        signal: transcriptAbort.signal,
      })
        .then(r => {
          if (!r.ok) throw new Error('transcript fetch failed: ' + r.status);
          return r.json();
        })
        .then(data => {
          if (transcriptAbort.signal.aborted) return;
          const transcript = Array.isArray(data?.transcript) ? data.transcript : [];
          const items = transcriptToChronoItems(transcript);
          const messageCount = countTranscriptMessages(transcript);
          const restoredTurns = messageCount || target.savedTurnCount || target.turnCount || 0;
          const revision = typeof data?.revision === 'string'
            ? data.revision
            : (target.remoteRevision || target.knownRevision || null);
          const lastUserMessage = extractLastUserMessage(transcript) || target.lastUserMessage || null;
          setSessions(prev => {
            const next = new Map(prev);
            const cur = next.get(key) || {};
            next.set(key, {
              ...cur,
              savedItems: items,
              savedTurnCount: restoredTurns,
              turnCount: restoredTurns,
              messageCount: messageCount || restoredTurns,
              lastUserMessage,
              lastUpdated: data?.last_updated || cur.lastUpdated || null,
              knownRevision: revision,
              remoteRevision: revision,
              hasExternalUpdate: false,
              isNewSession: false,
              status: 'connecting',
              source: 'history',
            });
            return next;
          });

          if (
            activeKeyRef.current !== key
            || historyResumeTokenRef.current !== resumeToken
          ) {
            return;
          }

          setChronoItems(items);
          orderCounterRef.current = nextOrder(items);
          setTurnCount(restoredTurns);

          const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
          const ws = new WebSocket(`${proto}//${location.host}/apps/chat/ws`);
          wsRef.current = ws;
          setSessions(prev => {
            const next = new Map(prev);
            const cur = next.get(key) || {};
            next.set(key, { ...cur, ws });
            return next;
          });

          ws.onopen = () => {
            if (activeKeyRef.current === key) {
              wsRef.current = ws;
              setWsStatus('connected');
            }
            ws.send(JSON.stringify({
              type: 'create_session',
              cwd: target.cwd || '~',
              resume_session_id: target.sessionId,
            }));
          };
          ws.onmessage = (e) => {
            try { handleWsMessage(JSON.parse(e.data), key); } catch {}
          };
          ws.onclose = () => {
            if (activeKeyRef.current === key) {
              setWsStatus('disconnected');
            }
            pendingEventsRef.current.delete(key);
            setSessions(prev => {
              const next = new Map(prev);
              const cur = next.get(key) || {};
              next.set(key, {
                ...cur,
                ws: null,
                status: 'history',
                source: 'history',
              });
              return next;
            });
          };
          ws.onerror = () => {
            if (activeKeyRef.current === key) {
              setWsStatus('disconnected');
            }
          };
        })
        .catch(err => {
          if (transcriptAbort.signal.aborted || err?.name === 'AbortError') {
            return;
          }
          console.error('[chat] failed to resume history session', err);
          if (
            activeKeyRef.current === key
            && historyResumeTokenRef.current === resumeToken
          ) {
            setWsStatus('disconnected');
            setChronoItems([{
              id: makeId(),
              type: 'text',
              role: 'system',
              content: 'Warning: Could not resume this session. Try another recent session.',
              streaming: false,
              order: orderCounterRef.current++,
            }]);
          }
          setSessions(prev => {
            const next = new Map(prev);
            const cur = next.get(key) || {};
            next.set(key, { ...cur, status: 'history', source: 'history' });
            return next;
          });
        })
        .finally(() => {
          if (transcriptFetchAbortRef.current === transcriptAbort) {
            transcriptFetchAbortRef.current = null;
          }
        });
    }, [sessions, handleWsMessage]);

    const refreshSessionFromDisk = useCallback((key, options = {}) => {
      const target = sessionsRef.current.get(key);
      if (!target || !target.sessionId) return;
      if (target.status === 'running' || target.status === 'loading_history') return;
      if (diskRefreshInFlightRef.current.has(key)) return;

      diskRefreshInFlightRef.current.add(key);
      const notifyBottom = !!options.notifyBottom;
      const activeOnly = !!options.activeOnly;
      if (activeOnly && activeKeyRef.current !== key) {
        diskRefreshInFlightRef.current.delete(key);
        return;
      }
      const previousCount = Number(
        target.messageCount || target.savedTurnCount || target.turnCount || 0
      );

      fetch('/apps/chat/api/sessions/' + encodeURIComponent(target.sessionId) + '/transcript')
        .then(r => {
          if (!r.ok) throw new Error('transcript fetch failed: ' + r.status);
          return r.json();
        })
        .then(data => {
          const transcript = Array.isArray(data?.transcript) ? data.transcript : [];
          const items = transcriptToChronoItems(transcript);
          const messageCount = countTranscriptMessages(transcript);
          const nextTurns = messageCount || target.savedTurnCount || target.turnCount || 0;
          const nextCount = Number(messageCount || nextTurns || 0);
          const revision = typeof data?.revision === 'string'
            ? data.revision
            : (target.remoteRevision || target.knownRevision || null);
          const lastUserMessage = extractLastUserMessage(transcript) || target.lastUserMessage || null;
          if (activeOnly && activeKeyRef.current !== key) return;

          setSessions(prev => {
            const next = new Map(prev);
            const cur = next.get(key) || {};
            next.set(key, {
              ...cur,
              savedItems: items,
              savedTurnCount: nextTurns,
              turnCount: nextTurns,
              messageCount: messageCount || nextTurns,
              lastUserMessage,
              lastUpdated: data?.last_updated || cur.lastUpdated || null,
              knownRevision: revision,
              remoteRevision: revision,
              hasExternalUpdate: false,
              isNewSession: false,
            });
            return next;
          });

          if (activeKeyRef.current !== key) return;
          const hasNewMessages = nextCount > previousCount;
          setChronoItems(items);
          orderCounterRef.current = nextOrder(items);
          setTurnCount(nextTurns);
          setExecuting(false);
          setPendingApproval(null);
          if (notifyBottom && hasNewMessages) {
            setDiskUpdateNoticeSignal(v => v + 1);
          }
        })
        .catch(err => {
          console.warn('[chat] failed to refresh session from disk', err);
          if (activeKeyRef.current !== key) return;
          setChronoItems(prev => [...prev, {
            id: makeId(),
            type: 'text',
            role: 'system',
            content: 'Warning: Could not refresh this session from disk.',
            streaming: false,
            order: orderCounterRef.current++,
          }]);
        })
        .finally(() => {
          diskRefreshInFlightRef.current.delete(key);
        });
    }, []);

    const switchSession = useCallback((key) => {
      const currentKey = activeKeyRef.current;
      if (key === currentKey) return;

      if (transcriptFetchAbortRef.current) {
        try { transcriptFetchAbortRef.current.abort(); } catch {}
        transcriptFetchAbortRef.current = null;
      }

      const target = sessions.get(key) || {};
      if (target.source === 'history') {
        resumeHistorySession(key);
        return;
      }

      // Save current session's messages
      if (currentKey) {
        setSessions(prev => {
          const next = new Map(prev);
          const cur = next.get(currentKey) || {};
          next.set(currentKey, {
            ...cur,
            savedItems: chronoItemsRef.current,
            savedTurnCount: turnCountRef.current,
          });
          return next;
        });
      }

      // Load target session
      const targetItems = target.savedItems || [];
      setChronoItems(targetItems);
      orderCounterRef.current = nextOrder(targetItems);
      setTurnCount(target.savedTurnCount || 0);
      setExecuting(target.status === 'running');
      setPendingApproval(null);
      setSessionId(target.sessionId || null);
      setCwd(target.cwd || '~');
      if (target.ws && target.ws.readyState === WebSocket.OPEN) {
        wsRef.current = target.ws;
        setWsStatus('connected');
      } else if (target.ws && target.ws.readyState === WebSocket.CONNECTING) {
        wsRef.current = target.ws;
        setWsStatus('connecting');
      } else {
        wsRef.current = null;
        setWsStatus('disconnected');
      }
      activeKeyRef.current = key;
      setActiveKey(key);
      setMobileSidebarOpen(false);
      blockMapRef.current = {};
      cycleRef.current = 0;
      localIndexRef.current = 0;
      const queued = pendingEventsRef.current.get(key);
      if (queued && queued.length > 0) {
        pendingEventsRef.current.delete(key);
        for (const queuedMsg of queued) {
          handleWsMessage(queuedMsg, key);
        }
      }
    }, [sessions, handleWsMessage, resumeHistorySession]);

    const pollSessionRevisions = useCallback(() => {
      if (revisionPollInFlightRef.current) return;

      const ids = [];
      const seen = new Set();
      const knownRevisions = {};
      const activeSession = activeKeyRef.current
        ? sessionsRef.current.get(activeKeyRef.current)
        : null;
      const activeSessionId = (activeSession && activeSession.sessionId) || null;
      for (const session of sessionsRef.current.values()) {
        if (!session || !session.sessionId) continue;
        if (seen.has(session.sessionId)) continue;
        const isActiveSessionId = activeSessionId && session.sessionId === activeSessionId;
        const ws = session.ws;
        if (
          ws
          && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)
          && !isActiveSessionId
        ) {
          continue;
        }
        seen.add(session.sessionId);
        ids.push(session.sessionId);
        knownRevisions[session.sessionId] = typeof session.knownRevision === 'string'
          ? session.knownRevision
          : null;
      }
      if (ids.length === 0) return;

      revisionPollInFlightRef.current = true;
      const payload = {
        limit: Math.max(300, ids.length + 20),
        session_ids: ids,
        known_revisions: knownRevisions,
      };

      fetch('/apps/chat/api/sessions/revisions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      })
        .then(r => {
          if (!r.ok) throw new Error('revision fetch failed: ' + r.status);
          return r.json();
        })
        .then(data => {
          const rows = Array.isArray(data?.changed) ? data.changed : [];
          const removed = Array.isArray(data?.removed) ? data.removed : [];
          if (!rows.length && !removed.length) return;
          const byId = new Map(
            rows
              .filter(r => r && typeof r.session_id === 'string')
              .map(r => [r.session_id, r])
          );
          const removedIds = new Set(
            removed.filter(v => typeof v === 'string')
          );

          setSessions(prev => {
            let changed = false;
            const next = new Map(prev);
            for (const [key, session] of next.entries()) {
              if (!session || !session.sessionId) continue;

              if (removedIds.has(session.sessionId)) {
                if (session.remoteRevision === null) continue;
                next.set(key, {
                  ...session,
                  remoteRevision: null,
                });
                changed = true;
                continue;
              }

              const row = byId.get(session.sessionId);
              if (!row || typeof row.revision !== 'string') continue;

              const remoteRevision = row.revision;
              const currentKnown = session.knownRevision ?? null;
              // Never advance knownRevision in the poll — null means "never reviewed
              // by this client". Only set a baseline when the user opens the session.
              const nextKnown = currentKnown;
              const hasExternalUpdate = currentKnown === null
                ? (remoteRevision !== null)   // never reviewed: badge if has content
                : currentKnown !== remoteRevision; // reviewed before: badge if changed
              const nextUpdatedAt = row.last_updated || session.lastUpdated || null;
              // Pick up name/description from revision scan (written by naming hook)
              const nextName = row.name || session.name || null;
              const nextDescription = row.description || session.description || null;

              if (
                session.remoteRevision === remoteRevision
                && session.knownRevision === nextKnown
                && !!session.hasExternalUpdate === hasExternalUpdate
                && session.lastUpdated === nextUpdatedAt
                && session.name === nextName
                && session.description === nextDescription
              ) {
                continue;
              }

              next.set(key, {
                ...session,
                remoteRevision,
                knownRevision: nextKnown,
                hasExternalUpdate,
                lastUpdated: nextUpdatedAt,
                name: nextName,
                description: nextDescription,
              });
              changed = true;
            }
            return changed ? next : prev;
          });
        })
        .catch(err => {
          if (String(err?.message || '').includes('401')) return;
          console.warn('[chat] failed to poll session revisions', err);
        })
        .finally(() => {
          revisionPollInFlightRef.current = false;
        });
    }, []);

    useEffect(() => {
      pollSessionRevisions();
      const intervalId = window.setInterval(pollSessionRevisions, 7000);
      const onFocus = () => pollSessionRevisions();
      const onVisibility = () => {
        if (document.visibilityState === 'visible') {
          pollSessionRevisions();
        }
      };
      window.addEventListener('focus', onFocus);
      document.addEventListener('visibilitychange', onVisibility);
      return () => {
        window.clearInterval(intervalId);
        window.removeEventListener('focus', onFocus);
        document.removeEventListener('visibilitychange', onVisibility);
      };
    }, [pollSessionRevisions]);

    useEffect(() => {
      if (!activeKey) return;
      const active = sessions.get(activeKey);
      if (!active || !active.sessionId || !active.hasExternalUpdate) return;
      if (executing || active.status === 'running' || active.status === 'loading_history') return;

      const now = Date.now();
      const lastAt = Number(autoDiskRefreshAtRef.current[activeKey] || 0);
      if (now - lastAt < 4000) return;
      autoDiskRefreshAtRef.current[activeKey] = now;

      refreshSessionFromDisk(activeKey, { notifyBottom: true, activeOnly: true });
    }, [activeKey, sessions, executing, refreshSessionFromDisk]);

    const applyDraftCwd = useCallback((rawCwd) => {
      const normalized = (rawCwd || '').trim() || '~';
      defaultCwdRef.current = normalized;
      setDefaultCwd(normalized);
    }, []);

    const startPaneResize = useCallback((pane, e) => {
      if (typeof window !== 'undefined' && window.innerWidth <= 768) return;
      e.preventDefault();
      const startWidth = pane === 'sessions' ? sessionPanelWidth : activityPanelWidth;
      dragStateRef.current = {
        pane,
        startX: e.clientX,
        startWidth,
      };
      setDraggingPane(pane);
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    }, [sessionPanelWidth, activityPanelWidth]);

    // —— Render ——————————————————————————————————————————————————————
    const sessionEntries = Array.from(sessions.entries());
    const filteredSessionEntries = sessionEntries.filter(([key, session]) =>
      sessionMatchesFilter(key, session, sessionFilterQuery)
    );
    const sessionTree = buildSessionTree(filteredSessionEntries);
    const rootSessionEntries = sessionTree.roots;
    const sessionKeyBySessionId = new Map(
      sessionEntries
        .filter(([, session]) => session && session.sessionId)
        .map(([key, session]) => [session.sessionId, key])
    );

    const renderSessionTreeEntry = (entry, depth = 0, lineage = new Set()) => {
      const [key, session] = entry;
      const cycleDetected = lineage.has(key);
      const children = cycleDetected
        ? []
        : (sessionTree.childrenByParentKey.get(key) || []);
      const hasChildren = children.length > 0;
      const collapseKey = (session && session.sessionId) || key;
      const collapsed = hasChildren
        ? (collapsedSpawnGroups[collapseKey] !== false)
        : false;
      const nextLineage = new Set(lineage);
      nextLineage.add(key);
      return html`
        <div class="session-tree-node" key=${'tree-' + key}>
          <div
            class="session-tree-row"
            style=${depth > 0 ? { marginLeft: (Math.min(depth, 8) * 12) + 'px' } : null}
          >
            ${hasChildren
              ? html`
                  <button
                    class="session-tree-toggle"
                    title=${collapsed ? 'Show spawned sessions' : 'Hide spawned sessions'}
                    onClick=${e => {
                      e.stopPropagation();
                      toggleSpawnGroup(collapseKey);
                    }}
                  >
                    <${Icon} name=${collapsed ? 'chevron-right' : 'chevron-down'} className="sm" />
                  </button>
                `
              : html`<span class="session-tree-spacer"></span>`
            }
            <div class="session-tree-card-wrap">
              <${SessionCard}
                key=${key}
                session=${session}
                isActive=${key === activeKey}
                onClick=${() => switchSession(key)}
              />
            </div>
          </div>
          ${hasChildren && !collapsed && html`
            <div class="session-tree-children">
              ${children.map(child => renderSessionTreeEntry(child, depth + 1, nextLineage))}
            </div>
          `}
        </div>
      `;
    };

    const directoryGroups = (() => {
      const groupsByDir = new Map();
      for (const entry of rootSessionEntries) {
        const [, session] = entry;
        const cwd = normalizeCwd(session && session.cwd);
        let group = groupsByDir.get(cwd);
        if (!group) {
          group = { key: cwd, cwd, items: [], latestTs: 0 };
          groupsByDir.set(cwd, group);
        }
        group.items.push(entry);
        const ts = sessionUpdatedTs(session);
        if (ts > group.latestTs) group.latestTs = ts;
      }

      const groups = Array.from(groupsByDir.values());
      for (const group of groups) {
        group.items.sort(compareSessionEntriesByRecent);
      }
      groups.sort((a, b) => {
        if (b.latestTs !== a.latestTs) return b.latestTs - a.latestTs;
        return a.cwd.localeCompare(b.cwd);
      });
      return groups;
    })();
    const hasSessionFilter = !!sessionFilterQuery.trim();
    const hasSessionResults = filteredSessionEntries.length > 0;
    const isSessionFilterOpen = showSessionFilter || hasSessionFilter;
    const showSyncButton = syncingHistory || pendingHistorySyncCount > 0;
    const activeSession = activeKey ? sessions.get(activeKey) : null;
    const activeSessionId = (activeSession && activeSession.sessionId) || sessionId || null;
    const activeParentSessionId = normalizeSessionParentId(
      activeSession && activeSession.parentSessionId
    );
    const activeParentKey = activeParentSessionId
      ? (sessionKeyBySessionId.get(activeParentSessionId) || null)
      : null;
    const showDraftCwdEditor =
      !!activeSession
      && activeSession.source !== 'history'
      && (activeSession.turnCount || 0) === 0
      && !executing;
    const closeMobileSidebar = useCallback(() => {
      setMobileSidebarOpen(false);
    }, []);

    const mainFilter = viewMode === 'workspace' ? (i => i.type === 'text') : null;
    const activityFilter = viewMode === 'workspace' ? (i => i.type !== 'text') : null;

    return html`
      <div id="header">
        <button
          class="hamburger"
          aria-label=${mobileSidebarOpen ? 'Close sessions panel' : 'Open sessions panel'}
          aria-controls="session-panel"
          aria-expanded=${mobileSidebarOpen ? 'true' : 'false'}
          onClick=${() => setMobileSidebarOpen(o => !o)}
        >☰</button>
        <${StatusDot} status=${wsStatus} />
        <span class="app-name">Amplifier</span>
        <span class="header-spacer"></span>
        <button
          class=${'btn workspace-toggle' + (viewMode === 'workspace' ? ' active' : '')}
          onClick=${() => setViewMode(m => m === 'workspace' ? 'chat' : 'workspace')}
        >${viewMode === 'workspace' ? 'Chat' : 'Workspace'}</button>
        <button class=${'btn' + (showSessions ? ' active' : '')} onClick=${() => setShowSessions(s => !s)}>
          Sessions
        </button>
        <button
          class="btn theme-toggle"
          title=${theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'}
          onClick=${() => setTheme(t => t === 'dark' ? 'light' : 'dark')}
        >
          <span class=${'theme-chip' + (theme === 'light' ? ' active' : '')}>
            <svg class="theme-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
              <circle cx="12" cy="12" r="4"></circle>
              <line x1="12" y1="2" x2="12" y2="5"></line>
              <line x1="12" y1="19" x2="12" y2="22"></line>
              <line x1="2" y1="12" x2="5" y2="12"></line>
              <line x1="19" y1="12" x2="22" y2="12"></line>
              <line x1="4.9" y1="4.9" x2="7" y2="7"></line>
              <line x1="17" y1="17" x2="19.1" y2="19.1"></line>
              <line x1="4.9" y1="19.1" x2="7" y2="17"></line>
              <line x1="17" y1="7" x2="19.1" y2="4.9"></line>
            </svg>
          </span>
          <span class=${'theme-chip' + (theme === 'dark' ? ' active' : '')}>
            <svg class="theme-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
              <path d="M21 14.5A8.5 8.5 0 1 1 9.5 3 7 7 0 0 0 21 14.5Z"></path>
            </svg>
          </span>
        </button>
      </div>

      <div id="app-body">
        ${mobileSidebarOpen && showSessions && html`
          <button
            class="mobile-sidebar-backdrop"
            aria-label="Close sessions panel"
            onPointerDown=${closeMobileSidebar}
            onClick=${closeMobileSidebar}
          ></button>
        `}
        <div
          id="session-panel"
          class=${(showSessions ? '' : 'hidden ') + (mobileSidebarOpen ? 'mobile-open ' : '') + (draggingPane === 'sessions' ? 'no-transition' : '')}
          style=${showSessions ? { width: sessionPanelWidth + 'px' } : { width: '0px' }}
        >
          <div class="session-panel-header">
            <div class="session-panel-header-top">
              <div class="session-panel-title-wrap">
                <span>Sessions</span>
              </div>
              <div class="session-panel-header-controls">
                <button class="session-new-btn" onClick=${newSession}>+ New</button>
                <button
                  class="mobile-session-close"
                  aria-label="Close sessions panel"
                  onPointerDown=${closeMobileSidebar}
                  onClick=${closeMobileSidebar}
                >x</button>
              </div>
            </div>
            <div class=${'session-panel-header-actions' + (showSyncButton ? ' has-sync' : '')}>
              <button
                class="session-control-btn"
                title=${sessionSortMode === 'recent'
                  ? 'Sorting by last updated time'
                  : 'Sorting by working directory'}
                onClick=${() => setSessionSortMode(mode => mode === 'recent' ? 'directory' : 'recent')}
              >
                <span>Sort</span>
                <span class="session-control-value">${sessionSortMode === 'recent' ? 'time' : 'dir'}</span>
              </button>
              <button
                class=${'session-control-btn' + (isSessionFilterOpen ? ' active' : '')}
                title="Show or hide session filter"
                onClick=${() => {
                  if (isSessionFilterOpen) {
                    setShowSessionFilter(false);
                    setSessionFilterQuery('');
                  } else {
                    setShowSessionFilter(true);
                  }
                }}
              >
                <span>Filter</span>
              </button>
              ${showSyncButton && html`
                <button
                  class=${'session-control-btn' + (pendingHistorySyncCount > 0 ? ' active' : '')}
                  title=${pendingHistorySyncCount > 0
                    ? ('Sync ' + pendingHistorySyncCount + ' new sessions from disk')
                    : 'Sync sessions from disk'}
                  onClick=${() => syncSessionHistory({ silent: false })}
                  disabled=${syncingHistory}
                >
                  <${Icon} name="refresh" className=${syncingHistory ? 'sm status-running' : 'sm'} />
                  <span>${syncingHistory ? 'Syncing' : 'Sync'}</span>
                </button>
              `}
            </div>
          </div>
          ${isSessionFilterOpen && html`
            <div class="session-filter-wrap">
              <input
                class="session-filter-input"
                value=${sessionFilterQuery}
                placeholder="Filter text or sid:abc123"
                spellcheck="false"
                onInput=${e => setSessionFilterQuery(e.target.value)}
              />
              ${hasSessionFilter && html`
                <div class="session-filter-hint">
                  ${hasSessionResults
                    ? (filteredSessionEntries.length + ' match' + (filteredSessionEntries.length === 1 ? '' : 'es'))
                    : 'No matches'}
                </div>
              `}
            </div>
          `}
          <div class="session-list">
            ${historyListLoading && html`
              <div class="session-list-loading">
                <span class="history-loading-dot"></span>
                <span>Loading past sessions…</span>
              </div>
            `}
            ${!historyListLoading && !hasSessionResults && html`
              <div class="session-list-loading">
                <span>${hasSessionFilter ? 'No sessions match this filter.' : 'No sessions yet.'}</span>
              </div>
            `}
            ${sessionSortMode === 'directory'
              ? directoryGroups.map(group => {
                  const collapsed = collapsedDirGroups[group.key] !== false;
                  return html`
                    <div class="session-dir-group" key=${'group-' + group.key}>
                      <button
                        class="session-dir-header"
                        onClick=${() => toggleDirGroup(group.key)}
                        title=${group.cwd}
                      >
                        <${Icon} name=${collapsed ? 'chevron-right' : 'chevron-down'} className="sm" />
                        <span class="session-dir-title">${group.cwd}</span>
                        <span class="session-dir-count">${group.items.length}</span>
                      </button>
                      ${!collapsed && html`
                        <div class="session-dir-items">
                          ${group.items.map(entry => renderSessionTreeEntry(entry))}
                        </div>
                      `}
                    </div>
                  `;
                })
              : rootSessionEntries.map(entry => renderSessionTreeEntry(entry))
            }
          </div>
          <div class="session-actions">
                ${showDraftCwdEditor
                  ? html`
                      <div class="new-session-cwd-label">New Session CWD</div>
                      <input
                        class="new-session-cwd-input"
                        value=${defaultCwd}
                        placeholder="~/project/path"
                        spellcheck="false"
                        onInput=${e => {
                          defaultCwdRef.current = e.target.value;
                          setDefaultCwd(e.target.value);
                        }}
                        onBlur=${e => applyDraftCwd(e.target.value)}
                      />
                    `
                  : html`
                  <div class="new-session-cwd-label">Session Metadata</div>
                  <div class="active-cwd-display">
                    ${activeSession
                      ? html`
                          <div class="session-meta-block">
                            <div class="session-meta-row" title=${cwd || '~'}>
                              <${Icon} name="folder" className="sm" />
                              <span class="session-meta-key">cwd</span>
                              <span class="session-meta-value">${cwd || '~'}</span>
                            </div>
                            <div class="session-meta-row" title=${activeSessionId || 'pending'}>
                              <${Icon} name="lock" className="sm" />
                              <span class="session-meta-key">sid</span>
                              <span class="session-meta-value">${activeSessionId || 'pending'}</span>
                            </div>
                            ${activeParentSessionId && html`
                              <button
                                class=${'session-meta-row session-meta-link' + (activeParentKey ? '' : ' pending')}
                                title=${activeParentKey
                                  ? ('Jump to parent session ' + activeParentSessionId)
                                  : ('Parent session ' + activeParentSessionId + ' is not loaded yet')}
                                onClick=${() => {
                                  if (activeParentKey) {
                                    switchSession(activeParentKey);
                                  } else {
                                    syncSessionHistory({ silent: false });
                                  }
                                }}
                              >
                                <${Icon} name="chevron-up" className="sm" />
                                <span class="session-meta-key">parent</span>
                                <span class="session-meta-value session-meta-value-link">${activeParentSessionId}</span>
                              </button>
                            `}
                            <div class="session-meta-row">
                              <span class="session-meta-key">turn</span>
                              <span class="session-meta-value">${turnCount}</span>
                            </div>
                          </div>
                        `
                      : 'No active session'}
                  </div>
                `
            }
          </div>
        </div>
        ${showSessions && html`
          <div
            class=${'pane-resizer' + (draggingPane === 'sessions' ? ' active' : '')}
            onMouseDown=${e => startPaneResize('sessions', e)}
          ></div>
        `}

        <div id="chat-main" class=${viewMode === 'workspace' ? 'workspace-mode' : ''}>
          <div class="main-pane">
            ${activeSession && activeSession.status === 'loading_history' && html`
              <div class="history-loading-banner">
                <span class="history-loading-dot"></span>
                <span>Loading session history…</span>
              </div>
            `}
            <${MessageList}
              items=${chronoItems}
              filterFn=${mainFilter}
              sessionKey=${(activeKey || 'none') + (viewMode === 'workspace' ? ':main-workspace' : ':main-chat')}
              showJumpControls=${true}
              bottomNoticeSignal=${diskUpdateNoticeSignal}
              bottomNoticeLabel="New messages"
            />
            <${InputArea}
              onSend=${sendMessage}
              onStop=${stopExecution}
              executing=${executing}
              viewMode=${viewMode}
              setViewMode=${setViewMode}
              activeKey=${activeKey}
            />
          </div>
          ${viewMode === 'workspace' && html`
            <div
              class=${'pane-resizer' + (draggingPane === 'activity' ? ' active' : '')}
              onMouseDown=${e => startPaneResize('activity', e)}
            ></div>
            <div class="activity-panel" style=${{ width: activityPanelWidth + 'px' }}>
              <div class="activity-panel-header">Activity</div>
              <div class="activity-scroll">
                <${MessageList}
                  items=${chronoItems}
                  filterFn=${activityFilter}
                  sessionKey=${(activeKey || 'none') + ':activity'}
                  showJumpControls=${false}
                />
              </div>
            </div>
          `}
        </div>
      </div>

      <${ApprovalModal} approval=${pendingApproval} onRespond=${respondToApproval} />
    `;
  }

  render(h(ChatApp, null), document.body);
</script>
</body>
</html>
